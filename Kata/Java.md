## Java
универсальный объектно-ориентированный язык со строгой типизацией.

## Основной принцип языка Java
В Java реализован принцип WORA (от английского: write once, run anywhere) или «Написано однажды - работает везде».
Написанное на Java приложение можно запускать везде, где есть среда исполнения [[Java#JRE|JRE]] (от английского: Java Runtime Environment). Механизм работы программ следующий. Исходный материал транслируется в [[Java#Byte Code|байт-код]], который обрабатывается [[Java#JVM|виртуальной машиной Java]] (JVM). При этом не имеет значения, какая операционная система установлена на устройстве.
## Кроссплатформенность
была достигнута за счёт создания **JVM**. [[Java#JVM|Java Virtual Machine]] - это программа, являющаяся прослойкой между операционной системой и Java программой. Задача JVM – исполнять [[Java#Byte Code|байт-код]].
Сама JVM реализована **нативно** для разных ОС. Байт код для JVM может исполняться везде где установлена JVM. Код не нужно перекомпилировать под каждую из платформ.
> [!info]- На JVM могут также работать другие java-подобные языки программирования
> - clojure
> - scala
> - jruby
> - jpython
## Преимущества Java
- **Объектно-ориентированное программирование** - структура данных становится объектом, которым можно управлять для создания отношений между различными объектами.
- **Язык высокого уровня с простым синтаксисом и плавной кривой обучения** Синтаксис Java основан на C++, поэтому Java похожа на C. Тем не менее, синтаксис Java проще, что позволяет новичкам быстрее учиться и эффективнее использовать код для достижения конкретных результатов.
- **Стандарт для корпоративных вычислительных систем** - корпоративные приложения — главное преимущество Java с 90-х годов, когда организации начали искать надежные инструменты программирования не на C.
- **Безопасность** - благодарю отсутсnвию указателей и Security Manager (политика безопасности, в которой можно указать правила доступа, позволяет запускать приложения Java в "песочнице").
- **Независимость от платформы** - Можно создать Java-приложение на Windows, скомпилировать его в байт-код и запустить его на любой другой платформе, поддерживающей виртуальную машину Java (JVM). Таким образом, JVM служит уровнем абстракции между кодом и оборудованием.
- **Язык для распределенного программирования и комфортной удаленной совместной работы** - Специфическая для Java методология распределенных вычислений называется Remote Method Invocation (RMI). RMI позволяет использовать все преимущества Java: безопасность, независимость от платформы и объектно-ориентированное программирование для распределенных вычислений. Кроме того, Java также поддерживает программирование сокетов и методологию распределения [[CORBA]] для обмена объектами между программами, написанными на разных языках.
- **Автоматическое управление памятью(спорный вопрос)** - Разработчикам Java не нужно вручную писать код для управления памятью благодаря автоматическому управлению памятью (AMM).
- **Многопоточность** Поток — наименьшая единица обработки в программировании. Чтобы максимально эффективно использовать время процессора, Java позволяет запускать потоки одновременно, что называется многопоточностью.
- **Стабильность и сообщество** - Сообщество разработчиков Java не имеет себе равных. Около 30% респондентов опроса StackOverflow 2023 используют Java.
## Недостатки Java
- **Платное коммерческое использование** (с 2019)(спорное утверждение);
- **Низкая производительность** из-за компиляции и абстракции с помощью виртуальной машины, а также приложение очистки памяти;
- **Многословный код** Java — это более легкая версия неприступного C++, которая вынуждает программистов прописывать свои действия словами из английского языка. Это делает язык более понятным для неспециалистов, но менее компактным.
- **Не развитые инструменты по созданию GUI** приложений на чистой java.
## JDK
**Java Development Kit** включает в себя:
- **JRE (Java Runtime Environment)**:
- Инструменты разработчика (в частности компилятор javac)
![[image java conceptual diagram.png]]
[Oracle documentation](https://docs.oracle.com/javase/8/docs/index.html)
## JRE
**Java Runtime Environment** - минимально-необходимая реализация виртуальной машины для исполнения Java-приложений, включает в себя:
- [[Java#JVM|JVM]]
- [[Java#Class Loader|ClassLoader]]
- Библиотеки (Основные `java.lang` `java.util`, прочие стандартные, интеграционные)

## JVM
Java Virtual Machine - виртуальная машина Java исполняет байт-код Java, предварительно созданный из кода **javac** компилятором с помощью встроенного интерпретатора байт-кода. Параллельно с JVM наиболее часто встречающиеся части кода переводятся в машинный код **JIT** компилятором.
> [!info] HotSpot одна из популярных реализаций JVM.
## Byte Code
Байт-код Java — набор инструкций, скомпилированный компилятором javac, исполняемый JVM.
## Class Loader
Используется для передачи в JVM скомпилированного байт-кода, который хранится в файлах с расширением **.class**
> [!info] `public abstract class ClassLoader` абстрактный класс, загрузку обеспечивают его наследники

### Классы загрузчики
При запуске JVM, используются три загрузчика классов:
- **BootstrapClassLoader** - базовый загрузчик, реализован нативно и является частью ядра [[Java#JVM|JVM]]загружает платформенные классы JDK из архива `rt.jar` (До 9 java, в последующем поделен на модули) и модули из `<Java-home>/lib`
- **ExtensionClassLoader** (Удален с 9 версии java) - загрузчик расширений - загружает классы расширений, которые по умолчанию находятся в каталоге `jre/lib/ext` (До 9 java), c 9 java его функционал выполняет **PlatformClassLoader** загружая модули из `<java-home>/lib/modules`, может загружать модули из других путей если они добавлены в модульный путь;
- **AppClassLoader (SystemClassLoader)** - системный загрузчик - загружает классы приложения, определенные в `CLASSPATH` (До 9 java). В Java 9 и более поздних версиях рекомендуется использовать опцию командной строки `--module-path` вместо переменной окружения `CLASSPATH`.

**ClassLoader** выполняет три основных действия в строгом порядке:
1. Загрузка байт-кода и создание экземпляра класса:
	- поиск класса среди загруженных ранее классов
	- получение байт-кода класса для загрузки
	- проверка корректности байт-кода
	- создание экземпляра класса
	- загрузка родительских классов
	Если родительские классы и интерфейсы не были загружены, то нужный класс считается незагруженным.
	[habr](https://habr.com/ru/articles/748758/)
1. Связывание: выполняет проверку, подготовку и (необязательно) разрешение.
    - **Проверка**: обеспечивает правильность импортируемого типа.
    - **Подготовка**: выделяет память для переменных класса и инициализация памяти значениями по умолчанию.
    - **Разрешение**: преобразует символические ссылки из типа в прямые ссылки.
2. **Инициализация**: вызывает код Java, который инициализирует переменные класса их правильными начальными значениями.
Все эти этапы выполняются последовательно с обязательным соблюдением следующих требований: • класс должен быть полностью загружен перед тем, как он будет слинкован; • класс должен быть полностью проверен и подготовлен перед инициализацией; • ошибки разрешения ссылок происходят во время выполнения программы (даже если они были обнаружены на этапе линковки).

Каждый загрузчик хранит указатель на родительский, чтобы суметь передать загрузку если сам будет не в состоянии этого сделать.
![[Pasted image 20230919095805.png]]

### Динамическая загрузка
Динамическая загрузка происходит "на лету" в ходе выполнения программы с помощью статического метода класса Class.forName(имя класса). Классы загружаются только когда используются(но некоторые базовые классы загружаются при старте приложения).

> [!example] Например: Мы не знаем какой класс нам понадобится и принимаем решение в ходе выполнения программы передавая имя класса в статический метод forName().

В Java реализована **ленивая загрузка классов**.
**ТРИ принципа загрузки классов:**
1. **Принцип делегирования**
    Запрос на загрузку класса передаётся родительскому загрузчику. Загрузка класса выполняется автоматически только, если родительский загрузчик не смог найти и загрузить класс.
2. **Принцип видимости** 
    Загрузчик видит только свои классы и классы родителя. Он не имеет понятия о классах, загруженных его потомком.    
3. **Принцип уникальности**    
    Класс может быть загружен только один раз. Делегирование позволит убедиться, что загрузчик, инициирующий загрузку класса, не перегрузит загруженный ранее в JVM класс.

> [!error] Исключения, которые могут быть выброшены из-за ошибки на этом этапе: ClassNotFoundException или NoClassDefFoundError.
## JIT
**JIT (Just-in-time compilation)** - компиляция на лету или динамическая компиляция - технология увеличения производительности программных систем, использующих байт-код, путем компиляции байт-кода в машинный код во время работы программы. В основном отвечает за оптимизацию производительности приложений во время выполнения.

> [!tip] **JIT-компилятор** анализирует часто используемый код и компилирует его в машинный код, что ускоряет выполнение программы.

**JIT-компилятор** работает во время выполнения программы и может динамически оптимизировать код в зависимости от того, как он используется.

## Garbage Collector
В Java используется автоматическое управление памятью. Программист выделяет память, а за освобождение отвечает JVM.
> [!warning] Сборщик мусора демон-поток который выполняет две задачи:
> - обнаружение мусора
> - очистка мусора
### Обнаружение мусора
Для обнаружения мусора есть два подхода:
- **Reference Counting**
- **Tracing** (используется в HotSpot)

#### Reference Counting (учет ссылок)
каждый объект в памяти имеет некоторый счетчик. Этот счетчик хранит информацию о том, сколько ссылок указывает на объект. Kогда какая-либо ссылка уничтожается, то и значение счетчика уменьшается. Если значение счетчика равно нулю - объект можно считать мусором и память, которую он занимает, можно очищать.
> [!tip] В таком подходе возникает проблема циклических ссылок(приводит к утечке памяти).

 ![[Pasted image 20230918195031.png|400]]
 
#### Tracing (используется в HotSpot)
помечает живые объекты - те, до которых мы можем добраться от корня (**GC Root**), в то время как все остальные являются мусором.

Существует 4 типа корневых точки:
- Локальные переменные и параметры методов;
- Потоки в стеке;
- Статические переменные;
- Ссылки из JNI (Java Native Interface) в нативных методах.
> [!warning] Самое простое java приложение будет иметь корневые точки:
> - Локальные переменные внутри main() метода и параметры main() метода;
> - Поток, который выполняет main();
> - Статические переменные класса, внутри которого находится main() метод.

Все что доступно с живого объекта - также живое.![[Pasted image 20230918195049.png|400]]
### Очистка мусора
Для очистки памяти от мусора существуют два основных метода:
- **Copying collectors**
- **Mark-and-sweep**
#### Copying collectors
При **copying collectors** подходе память делится на две части «from-space» и «to-space», при этом сам принцип работы такой:
- Объекты создаются в «from-space»
- Когда «from-space» заполняется, приложение приостанавливается
- Запускается сборщик мусора. Находятся живые объекты в «from-space» и копируются в «to-space»
- Когда все объекты скопированы «from-space» полностью очищается
- «to-space» и «from-space» меняются местами

> [!success] Главный плюс такого подхода в том, что объекты плотно забивают память.

> [!fail] Минусы подхода:
> - Приложение должно быть остановлено на время, необходимое для полного прохождения цикла сборки мусора;
> - В худшем случае (когда все объекты живые) «form-space» и «to-space» будут обязаны быть одинакового размера.

#### Mark-and-sweep
Алгоритм работы **mark-and-sweep** можно описать так:
- Объекты создаются в памяти
- В момент, когда нужно запустить сборщик мусора приложение приостанавливается
- Сборщик проходится по дереву объектов, помечая живые объекты
- Сборщик проходится по всей памяти, находя все не отмеченные куски памяти и сохраняя их в «free list»
- Когда новые объекты начинают создаваться они создаются в памяти доступной во «free list»

> [!fail] Минусы этого способа:
> - Приложение не работает пока происходит сборка мусора;
> - Время остановки напрямую зависит от размеров памяти и количества объектов;
> - Если не использовать «compacting» память будет использоваться не эффективно.

#### Generational Garbage Collection
Сборщики мусора HotSpot VM используют комбинированный подход **Generational Garbage Collection**, который позволяет использовать разные алгоритмы для разных этапов сборки мусора.
> [!info] Этот подход базируется на том, что:
> - большинство создаваемых объектов быстро становятся мусором;
> - существует мало связей между объектами, которые были созданы в прошлом и только что созданными объектами.

### Как определяется производительность для сборщика мусора?
- Throughput (пропускная способность) – объём вычислительных ресурсов, затрачиваемых сборщиком мусора
- Latency (задержка) – на какое время прерывается работа приложения для работы сборщика мусора
- Footprint (след) – объём памяти, используемый сборщиком мусора
Можно и нужно выбирать оптимальную стратегию, исходя из целей разработки.

### Взаимодействие сборщика мусора с приложением
Есть два алгоритма работы сборщика мусора с точки зрения взаимодействия с приложением:
- **STW «stop-the-world»** - остановка приложения на период уборки (остановка нужна, чтоб никакие новые изменения не произошли в программе, новые объекты не появились и т.д.)
> [!success] Плюсы алгоритма:
> - проще определять достижимость объектов «граф объектов заморожен»)
> - проще перемещать объекты в куче (в процессе сборки куча может находиться в некорректном состоянии)

> [!fail] Минусы:
> - приложение останавливается на время сборки мусора
> - зависит от размера кучи (объёма памяти живых объектов)
- **Инкрементальная сборка**
> [!success] Попытка уменьшить паузы, вызванные GC (за счёт большого количества коротких пауз и фоновой сборки)

> [!fail] Минусы
> Требуется синхронизировать работу GC с приложением (барьеры на чтение/запись)
> Такой алгоритм занимает больше времени.

 ![[Pasted image 20230918195153.png|400]]

## Виды сборщиков мусора в HotSpot VM:
Java HotSpot VM предоставляет разработчикам на выбор семь различных сборщика мусора:
- **Serial (последовательный)** — самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. Редко когда используется, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию.
- **Parallel (параллельный)** — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности.
- **Concurrent Mark Sweep (CMS)** — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти. Использует инкрементальный алгоритм сборки.
- **Garbage-First (G1)** — создан для постепенной замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных.
- **Epsilon GC** — разработан для случаев, когда сборка мусора вообще не нужна. Epsilon GC занимается только аллокацией памяти и ничего не делает для её освобождения. При достижении лимита памяти виртуальная машина Java остановится. Служит для тестирования производительности, анализа накладных расходов других сборщиков мусора, облегчения разработки виртуальной машины.
- **ZGC** — пытается удерживать паузы на субмиллисекундном уровне, даже при работе с очень большими кучами.
- **Shenandoah GC** — еще один сборщик, нацеленный на ультракороткие паузы независимо от размера кучи.
### Сборка мусора разными сборщиками:
#### Serial GC
При использовании данного сборщика куча разбивается на четыре региона, три из которых относятся к младшему поколению (Eden, Survivor 0 и Survivor 1), а один (Tenured) — к старшему:
![[Pasted image 20230919115428.png|600]]
При создании объекта, JVM помещает его в регион Eden.
> [!tip] бывают еще объекты-акселераты, размер которых настолько велик, что создавать их в Eden, а потом таскать за собой по Survivor’ам слишком накладно. В этом случае они размещаются сразу в Tenured

Когда заканчивается место в Eden, запускается малая сборка мусора
- живые объекты копируются в S1
- Вся область Eden очищается.
- S1 и S2 меняются местами (При последующих циклах в S1 будут записаны живые объекты как из Eden, так и из S2)
![[Pasted image 20230919120401.png|600]]
После определенного количества циклов обмена S1 и S2 для объекта или заполнения области S2, объекты, которые живут достаточно долго перемещаются в Старшее поколение.

Когда после очередной сборки мусора места не хватает уже в Tenured, то запускается полная сборка мусора, работающая с объектами из обоих поколений. При этом старшее поколение не делится на регионы по аналогии с младшим, а представляет собой один большой кусок памяти, поэтому после удаления мертвых объектов из Tenured производится не перенос данных (переносить уже некуда), а их уплотнение, то есть размещение последовательно, без фрагментации  (алгоритм Mark-Sweep-Compact).
![[Pasted image 20230919120915.png|600]]
> [!tip] Если после полной сборки мусора места нехватает, то вылетает Java.lang.OutOfMemoryError.


По мере заполнения кучи данными JVM может не только проводить чистку памяти, но и запрашивать у ОС выделение дополнительной памяти для расширения регионов. Причем в случае, если реально используемый объем памяти падает ниже определенного порога, JVM может вернуть часть памяти операционной системе. Для регулирования аппетита виртуальной машины существуют известные всем опции `Xms` и `Xmx`.
Тут также стоит отметить, что по умолчанию младшее поколение занимает одну треть всей кучи, а старшее, соответственно, две трети. При этом каждый регион Survivor занимает одну десятую младшего поколения, то есть Eden занимает восемь десятых. В итоге реальные пропорции регионов по умолчанию выглядят так:
![[Pasted image 20230919121101.png|600]]

Эффективность алгоритма сборки мусора считается по параметру STW (StopTheWorld) - время, когда все процессы кроме GC останавливаются. Serial в этом смысле не слишком эффективен, т.к. делает свою работу не торопясь, в одном потоке.
[habr](https://habr.com/ru/articles/269707/)
#### Parallel GC:
Parallel GC (параллельный сборщик) развивает идеи, заложенные последовательным сборщиком, добавляя в них параллелизм и немного интеллекта. Если на вашем компьютере больше одного процессорного ядра и вы явно не указали, какой сборщик хотите использовать в своей программе, то почти наверняка JVM остановит свой выбор на Parallel GC. Он достаточно простой, но в то же время достаточно функциональный, чтобы удовлетворить потребности большинства приложений.
[habr](https://habr.com/ru/articles/269707/)

#### CMS GC:
CMS GC использует ту же самую организацию памяти, что и уже рассмотренные Serial / Parallel GC: регионы Eden + Survivor 0 + Survivor 1 + Tenured и такие же принципы малой сборки мусора. Отличия начинаются только тогда, когда дело доходит до полной сборки. В случае CMS ее называют _старшей (major) сборкой_, а не полной, так как она не затрагивает объекты младшего поколения. В результате, малая и старшая сборки здесь всегда разделены. Одним из побочных эффектов такого разделения является то, что все объекты младшего поколения (даже потенциально мертвые) могут играть роль корней при определении статуса объектов в старшем поколении.
Важным отличием сборщика CMS от рассмотренных ранее является также то, что он не дожидается заполнения Tenured для того, чтобы начать старшую сборку. Вместо этого он трудится в фоновом режиме постоянно, пытаясь поддерживать Tenured в компактном состоянии.

Из всего сказанного выше следует, что при обычной сборке мусора у CMS GC существуют следующие ситуации, приводящие к STW:  
- Малая сборка мусора. Эта пауза ничем не отличается от аналогичной паузы в Parallel GC.
- Начальная фаза поиска живых объектов при старшей сборке (так называемая _initial mark pause_). Эта пауза обычно очень короткая.
- Фаза дополнения набора живых объектов при старшей сборке (известная также как _remark pause_). Она обычно длиннее начальной фазы поиска.
[habr](https://habr.com/ru/articles/269863/)
#### G1 GC:
Память разбивается на множество регионов одинакового размера. Размер этих регионов зависит от общего размера кучи и по умолчанию выбирается так, чтобы их было не больше 2048, обычно получается от 1 до 32 МБ. Исключение составляют только так называемые *громадные* (humongous) регионы, которые создаются объединением обычных регионов для размещения очень больших объектов.  
  
Разделение регионов на Eden, Survivor и Tenured в данном случае логическое, регионы одного поколения не обязаны идти подряд и даже могут менять свою принадлежность к тому или иному поколению. Пример разделения кучи на регионы может выглядеть следующим образом (количество регионов сильно приуменьшено):
![[Pasted image 20230919122243.png|600]]
Малые сборки выполняются периодически для очистки младшего поколения и переноса объектов в регионы Survivor, либо их повышения до старшего поколения с переносом в Tenured. Над переносом объектов трудятся несколько потоков, и на время этого процесса работа основного приложения останавливается. Это уже знакомый нам подход из рассмотренных ранее сборщиков, но отличие состоит в том, что очистка выполняется не на всем поколении, а только на части регионов, которые сборщик сможет очистить не превышая желаемого времени. При этом он выбирает для очистки те регионы, в которых, по его мнению, скопилось наибольшее количество мусора и очистка которых принесет наибольший результат. Отсюда как раз название Garbage First — мусор в первую очередь.

А с полной сборкой (точнее, здесь она называется _смешанной (mixed)_) все немного хитроумнее, чем в рассмотренных ранее сборщиках. В G1 существует процесс, называемый _циклом пометки (marking cycle)_, который работает параллельно с основным приложением и составляет список живых объектов. За исключением последнего пункта, этот процесс выглядит уже знакомо для нас:  
1. Initial mark. Пометка корней (с остановкой основного приложения) с использованием информации, полученной из малых сборок.
2. Concurrent marking. Пометка всех живых объектов в куче в нескольких потоках, параллельно с работой основного приложения.
3. Remark. Дополнительный поиск не учтенных ранее живых объектов (с остановкой основного приложения).
4. Cleanup. Очистка вспомогательных структур учета ссылок на объекты и поиск пустых регионов, которые уже можно использовать для размещения новых объектов. Первая часть этого шага выполняется при остановленном основном приложении.

После окончания цикла пометки G1 переключается на выполнение смешанных сборок. Это значит, что при каждой сборке к набору регионов младшего поколения, подлежащих очистке, добавляется некоторое количество регионов старшего поколения. Количество таких сборок и количество очищаемых регионов старшего поколения выбирается исходя из имеющейся у сборщика статистики о предыдущих сборках таким образом, чтобы не выходить за требуемое время сборки. Как только сборщик очистил достаточно памяти, он переключается обратно в режим малых сборок.
Очередной цикл пометки и, как следствие, очередные смешанные сборки будут запущены тогда, когда заполненность кучи превысит определенный порог.
Опираясь на уже упомянутую статистику о предыдущих сборках, G1 может менять количество регионов, закрепленных за определенным поколением, для оптимизации будущих сборок.
Громадные регионы. С точки зрения JVM любой объект размером больше половины региона считается громадным и обрабатывается специальным образом:
- никогда не перемещается между регионами
- может удаляться в рамках цикла пометки или полной сборки мусора
- в регионе, занятом громадным объектом, может находится только он сам.
Громадные объекты в силу небольшого размера регионов могут порождать проблемы с точки зрения STW.
G1 выигрывает по времени STW, но расплатой является меньшая пропускная способность (около 90%, ср., например у Parallel. 99%) т.е. большие затраты ресурсов процессора.
[habr](https://habr.com/ru/articles/269863/)

#### ZGC
[habr](https://habr.com/ru/articles/680038/)
#### Shenandoah GC
[habr](https://habr.com/ru/articles/681256/)



## Виды ссылок в Java
1. **StrongReference** - это самые обычные ссылки которые мы создаем каждый день, любая переменная ссылочного типа.
```java
StringBuilder builder = new StringBuilder(); 
```
`builder` это и есть strong-ссылка на объект `StringBuilder`.
> [!warning] Любой объект что имеет strong ссылку запрещен для удаления сборщиком мусора

1. **SoftReference** - GC гарантировано удалит с кучи все объекты, доступные только по soft-ссылке, перед тем как бросит `OutOfMemoryError`. SoftReference это наш механизм кэширования объектов в памяти, но в критической ситуации, когда закончится доступная память, GC удалит не использующиеся объекты из памяти и тем самым попробует спасти JVM от завершения работы.
```java
StringBuilder builder = new StringBuilder();
SoftReference<StringBuilder> softBuilder = new SoftReference(builder);
``` 
`softBuilder.get()` - вернет strong-ссылку на объект `StringBuilder` в случае если GC не удалил этот объект из памяти. В другом случае вернется `null`.
`softBuilder.clear()` - удалит ссылку на объект StringBuilder.
То же самое работает для WeakReference.

3. **WeakReference** - если GC видит, что объект доступен только через цепочку weak-ссылок (исчезли strong-ссылки), то он удалит его из памяти.
```java
Object object = new Object();
WeakReference<Object> weakReference = new WeakReference<>(object);
```

4. **PhantomReference** - если GC видит что объект доступен только через цепочку phantom-ссылок, то он его удалит из памяти. После нескольких запусков GC.
```java
Object object = new Object();
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();
PhantomReference<Object> phantomReference = new PhantomReference<>(object, referenceQueue);
``` 
Особенностей у этого типа ссылок две.
- Первая это то, что метод `get()` всегда возвращает `null`. Именно из-за этого `PhantomReference` имеет смысл использовать только вместе с `ReferenceQueue`.
- Вторая особенность – в отличие от `SoftReference` и `WeakReference`, GC добавит phantom-ссылку в `ReferenceQueue` после того как выполниться метод `finalize()`.

Вернемся к `PhantomReference`. Этот тип ссылок в комбинации с `ReferenceQueue` позволяет нам узнать, когда объект более недоступен и на него нет других ссылок. Это позволяет нам сделать очистку ресурсов, используемых объектом, на уровне приложения. В отличии от `finalize()` мы сами контролируем процесс очистки ресурсов.

**ReferenceQueue** - позволяет отслеживать момент, когда GC определит что объект более не нужен и его можно удалить. Именно сюда попадает Reference объект после того как объект на который он ссылается удален из памяти. При создании `Reference` мы можем передать в конструктор `ReferenceQueue`, в который будут помещаться ссылки после удаления.

**finalize()** - вызывается Java-машиной у объекта перед тем, как объект будет уничтожен.

## Структура памяти JVM
**Для оптимальной работы приложения JVM делит память на:**
- **Stack** – тут хранятся примитивы и ссылки на объекты
- **Heap** – тут создаются и хранятся объекты

Обе области хранятся в **RAM**.
![[Pasted image 20230918195659.png|600]]
**Stack** отвечает за хранение ссылок на объекты кучи.
Он содержит staсk frame'ы, а они делятся на три части:
- параметры метода;
- указатель на предыдущий фрейм;
- локальные переменные.

**Stack** это область хранения данных, находящееся в общей оперативной памяти (RAM).
Всякий раз, когда вызывается метод, в памяти стека создается новый блок-фрейм, который содержит локальные переменные метода и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода.
Размер стековой памяти намного меньше объема памяти в куче.
Стек в Java работает по схеме LIFO.


> [!info] **Особенности стека:**
> - Он заполняется и освобождается по мере вызова и завершения новых методов;
> - Переменные в стеке существуют до тех пор, пока выполняется метод, в котором они были созданы;
> - Если память стека будет заполнена, Java бросит исключение `StackOverFlowError`;
> - Доступ к этой области памяти осуществляется быстрее, чем к куче;
> - Стек потокобезопасен, т.к. для каждого потока создается свой отдельный стек.

Структура **Heap** зависит от выбранного сборщика мусора.
**Heap** - структура данных, с помощью которой реализована динамически распределяемая память приложения.

**Для Java 11 и выше** Значение Xmx составляет 25% доступной памяти с максимальным объемом 25 ГБ. Однако при наличии 2 ГБ или менее физической памяти устанавливается значение 50 % доступной памяти с минимальным значением 16 МБ и максимальным значением 512 МБ.
**Для Java 8** значение Xmx — это половина доступной памяти, минимум 16 МБ и максимум 512 МБ.

> [!info] **Особенности кучи:**
> - Когда эта область памяти полностью заполняется, Java бросит `OutOfMemoryError`;
> - Доступ к ней медленнее, чем к стеку;
> - Эта память, в отличие от стека, автоматически не освобождается. Для сбора неиспользуемых объектов используется сборщик мусора;
> - В отличие от стека, куча не является потокобезопасной и ее необходимо контролировать, правильно синхронизируя код.

С помощью опций **-Xms** и **-Xmx** можно настроить начальный и максимально допустимый размер кучи соответственно. Существуют также опции для настройки величины стека.
![[Pasted image 20230918195732.png|600]]
**PermGen** - устаревший MetaSpase который встраивался в Heap. По умолчанию, максимальный размер этой области памяти для 32-х битной JVM равен 64 Мб, а для 64-х битной версии — 82 Мб. 
`-XX:PermSize=[размер]` для установки минимального размера PermGen области 
`-XX:MaxPermSize=[размер]` для установки максимального размера
Из-за своего ограниченного размера, PermGen является причиной возникновения ошибки `java.lang.OutOfMemoryError: PermGen space`.

**Metaspace** – новая область памяти, появившаяся в 8 версии Java и заменившая устаревшую PermGen. Основное их отличие заключается в способе распределения памяти. По умолчанию, Metaspace увеличивается автоматически. Однако и здесь у нас есть возможность управления памятью: при помощи `MetaspaceSize` и `MaxMetaspaceSize` можно задать границы Metaspace области.
В результате появления Metaspace, процесс очистки памяти получил некоторые преимущества. Теперь сборщик мусора автоматически удаляет из памяти ненужные классы, когда емкость, выделенная для хранения метаданных, достигает максимального значения.

> [!tip] В куче есть ссылки между объектами и их классами. На этом основана рефлексия.