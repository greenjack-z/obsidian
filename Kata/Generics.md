---
tags:
  - kata
  - java
  - core
---
## Generics
Параметризованные типы для реализации обобщённого программирования.

> [!info]- Обобщённое программирование:
> особый подход к описанию данных и алгоритмов, позволяющее работать с различными типами данных без изменения их описания. Например, нужно реализовать общую библиотечную логику, которая м.б. применена к объектам разных типов.

Начиная с 5й версии Java есть возможность параметризации классов, интерфейсов и методов каким-то типом. Можно объявлять и затем использовать некоторую переменную, в качестве которой будет подставлен любой тип, удовлетворяющий условиям.

Используя дженерики, можно создать единственный класс, который будет автоматически работать с разными типами данных. Так, например организованы коллекции (вместо `String` можно подставить другой тип а методы коллекции останутся те же)

```java
List<String> list = new ArrayList<>();
```

> [!tip] **Синтаксический сахар** (англ. syntactic sugar) в языке программирования - это синтаксические возможности, применение которых не влияет на поведение программы, но делает использование языка более удобным для человека.

Параметризовать можно классы, методы.

> [!question] **Можно ли параметризовать массив?** 
> Нет, т.к. неизвестен тип и не понятно, сколько памяти выделить.

### Параметр vs Аргумент. (в дженериках)?
**Параметр** – это тип данных, которыми оперируют классы, интерфейсы указанные в дженериках. Параметр типа (type parameter) используются при объявлении дженерик-типов. Например, для `Box <T>` T — это ***параметр*** типа.
**Аргумент** типа (type argument). Тип объекта, который может использоваться вместо параметра типа. Например, для `Box <Paper>` Paper — это ***аргумент*** типа.

## Why Use Generics?
1. Более сильная проверка типов во время компиляции.
	Компилятор Java применяет строгую проверку типов к универсальному коду и выдает ошибки если код нарушает безопасность типов. Исправить ошибки на стадии компиляции проще, чем в рантайме.
	
2. Устранение необходимости явного приведения (кастинга)
	Без дженериков
	```java
	List list = new ArrayList();
	list.add("hello");
	String s = (String) list.get(0);
	```
	С дженериками
	```java
	List<String> list = new ArrayList<String>();
	list.add("hello");
	String s = list.get(0);   // no cast
	```

3. Возможность реализовывать общие алгоритмы.
	Используя обобщенные типы программисты могут реализовать обобщенные алгоритмы, которые работают с коллекциями различных типов, при этом могут кастомизироваться, безопасны для типов и легко читаются.

**Ограничения**:
- Параметризация возможна только ссылочными типами
	``` java
	//можно
	Class <String> class;
	Class <Integer> class;
	Class <int[]> class;
	
	//нельзя
	Class <int> class;
	Class <10> class;
	```
- Нельзя создать параметризованные статические поля внутри обобщенного класса или иметь статические методы с параметризованными типами в качестве параметров.
```java
class MyClass<T>  
{  
    private Collection<T> myCol1; // нормально  
    private static Collection<T> myCol2; // ошибка  
}
```
- Внутри обобщенного класса нельзя создать экземпляр объекта или массива объектов параметризованного типа.
```java
class Class<T> {
	T field = new T(); //нельзя
	T[] array = new T[10] //нельзя
} 
```
- не работает `instanceof` т.к. внутри класса ничего про конкретное значение параметра неизвестно.
- ограничение наследования;
    ```java
    List<String> strings = new ArrayList<String>(); // ошибка компиляции!
    ```
    Между объектом и коллекцией объектов есть важное различие.
    Vы не можем привести `List<String>` к `List<Object`. `String` является наследником `Object` но `List<String>` не является наследником `List<Object>`.
- Можно сгенерировать исключение обобщенного типа; однако в блоке catch придется использовать конкретный тип, вместо обобщенного.
- у параметризованного класса не может быть двух перегруженных методов, у которых будет та же самая подпись после стирания типа.
> [!warning] при компиляции обобщенного кода, он лишается всех параметрических типов, и каждая ссылка на параметрический тип заменяется классом (как правило, Object или нечто более специальное). Этот процесс называется стиранием типов.

[Подробнее про стирание типов](http://www.cyberguru.ru/programming/java/java-generics-pt2.html?showall=1)
[Oracle](https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html)

### Типизированные методы
Дженерики позволяют типизировать методы.
Generic methods — это методы, которые вводят собственные параметры типа.
> [!tip] область действия параметра типа ограничена методом, в котором он объявлен.

Допускаются статические и нестатические универсальные методы, а также конструкторы универсальных классов.
Важно запомнить про синтаксис Generic methods:
1. включает список типизированных параметров **внутри** угловых скобок <>
2. список типизированных параметров идёт **до** типа возвращаемого значения метода
Статический и другой метод можно параметризовать отдельно от класса, объявив обобщенные параметры в угловых скобках ***после*** модификаторов, но ***перед*** типом   возвращаемого значения.
```java
public class Util {
	public static <K,V> boolean compare(Pair<K,V>p1, Pair<K,V>p2) {
		return p1.getKey().equals(p2.getKey()) && p1.getValue.equals(p2.getValue());
	}
}
```
Полный синтаксис для вызова данного метода следующий:
```java
Pair<Integer, String> p1 = new Pair<>(1, "Apple");
Pair<Integer, String> p2 = new Pair<>(2, "Pear");
boolean isSame = Util.<Integer, String>compare(p1, p2);

boolean isSame = Util.compare(p1, p2); //тоже можно, компилятор выведет нужный тип
```

### Типизированные классы
Типизировать можно не только методы, но и сами классы.
> [!warning] параметры на уровне класса используются для параметризации ***экземпляров*** класса

```java
public class Class<T> {
	private final T value;
	
	private Class(T value) {
		this.value = value;
	}
	...
}
```
для использования параметризованного класса, конкретный параметр указывается в угловых скобках ***после*** имени класса.
```java
List<String> list = new ArrayList<>();
```
Типизированный класс может иметь несколько параметров типа `Pair<Integer, String>`

## Cырые типы (raw type)
**Сырые типы** - это типы без указания типа в фигурных скобках List list, они использовались до появления дженериков. Не указывая их, под капотом используется Object.
Нужны чтобы поддерживать обратную совместимость.
```java
ArrayList<String> strings = new ArrayList<>(); // parameterized type
ArrayList arrayList = new ArrayList(); // raw type
arrayList = strings; // Ok
strings = arrayList; // Unchecked assignment (назначение)
arrayList.add(1); //unchecked call
```
Для того, чтобы не забывать указывать параметры в дженериках, ввели специальный синтаксис - diamond оператор `<>`. Компилятор смотрит на наличие оператора в правой части и проверяет указание типа в левой части, если не находит показывает предупреждение.

## Wildcard
Wildcard — это дженерик вида `<?>`, что означает, что тип может быть чем угодно. Используется, например, в коллекциях, где для всех коллекций базовым типом является `Сollection <?>`
Решает проблему наследования типов в дженериках.
1. Upper bounded wildcard
	Используются, когда мы хотим ***ослабить*** ограничение на переменную.
> [!example] Пример:
> написать метод, который будет работать c `List<Integer>`, `List<Double>` и `List<Number>`.

Можно реализовать используя wildcard с верхней границей. Ключевое слово `extends`
```java
public static void add(List<? extends Number> list);
```

2. Lower bounded wildcard
	показывает что переменная может быть родителем указанного типа.
```java
List<? super Integer> list;
```

3. Unbounded wildcard
	используется при написании метода, который можно использовать с помощью функций предоставленных в классе `Object`, а также когда код использует методы универсального класса не зависящие от параметра типа.
```java
public static void printList(List<?> list);
```

## принцип PECS
Producer Extends Consumer Super (также известен как GAPP(Get And Put Principle)).

Если вы только получаете объекты из дженерик-коллекции - это producer и надо использовать `extends`.
Если вы только кладете объекты в коллекцию - это consumer и надо использовать `super`.
Если вы делаете оба эти действия, то не надо использовать ни super, ни extends.

Например: `List<? extends Paper>` означает, что список может состоять из объектов типа Paper и всех его подтипов, а в `List<? super Paper>` могут быть объекты типа Paper и всех супертипов — например, Garbage или Object.

Из одного типа переменных можно только читать, в другой — только вписывать (исключением является возможность записать null для extends и прочитать Object для super).
![[Pasted image 20230925112623.png| 600]]

```java
class Garbage {}
class Paper extends Garbage {}
class CoolPaper extends Paper{}

public void testUpperBounding(List<? extends Paper> list){
   Paper p = list.get(0); // OK
   Garbage g = list.get(1); // OK
   CoolPaper sp = list.get(2); // не скомпилируется
   list.add(new Paper()); // не скомпилируется
   list.add(null); // OK
}

public void testLowBounding(List<? super Paper> list){
   Paper p = list.get(0); // не скомпилируется
   Garbage g = list.get(1); // не скомпилируется
   Object o = list.get(2); // OK
   list.add(new Garbage()); // не скомпилируется
   list.add(new Paper()); // OK
   list.add(new CoolPaper()); // OK
}
```

