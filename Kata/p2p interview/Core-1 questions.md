---
aliases:
  - core1
tags:
  - kata
  - core
  - java
  - questions
  - core1
---
```dataview
TABLE WITHOUT ID
(length(filter(this.file.tasks.completed, (t) => t = true))) AS ОК,
(length(filter(this.file.tasks.completed, (t) => t = false))) AS Осталось,
(length(this.file.tasks)) AS Всего,
(length(filter(this.file.tasks.completed, (t) => t = true))) / (length(this.file.tasks)) * 100 AS "% OK"
WHERE file.path = this.file.path
```
## ООП
Вопросов в разделе: `= (length(filter(this.file.tasks.section, (h) => meta(h).subpath = "ООП")))`

> [!question]- Что такое ООП?
> ![[OOP (Object-Oriented Programming)#ООП|oop]]
> - [x] OK

> [!question]- Какие преимущества у ООП?
> ![[OOP (Object-Oriented Programming)#Преимущества ООП|oop]]
> - [x] OK

> [!question]- Какие недостатки у ООП?
> ![[OOP (Object-Oriented Programming)#Недостатки ООП]]
> - [x] OK

> [!question]- Назовите основные принципы ООП.
> ![[OOP (Object-Oriented Programming)#Основные принципы ООП]]
> - [x] OK

> [!question]- Что такое инкапсуляция?
> ![[Encapsulation#Инкапсуляция]]
> - [x] OK

> [!question]- Что такое наследование?
> ![[Inheritance#Наследование]]
> - [x] OK

> [!question]- Что такое полиморфизм?
> ![[Polymorphizm#Полиморфизм]]
> - [x] OK

> [!question]- Что такое абстракция?
> ![[Abstraction#Абстракция]]
> - [x] OK

> [!question]- Что такое ассоциация, агрегация и композиция?
> ![[Association#Ассоциация]]
> - [x] OK

> [!question]- Расскажите про раннее и позднее связывание.
> ![[Binding]]
> - [x] OK

> [!question]- Что такое SOLID?
> ![[SOLID]]
> - [x] OK

> [!question]- Какие еще принципы можешь назвать?
> ![[DRY (Don't Repeat Yourself)]]
> ![[OR (Occam's Razor)]]
> ![[KISS (Keep It Simple Stupid)]]
> ![[YAGNI (You Aren't Gonna Need IT)]]
> ![[BDUF (Big Design Up Front)]]
> ![[Open & Close]]
> ![[SLAP (Single Level of Abstraction Principle)]]
> ![[CQS (сommand-query separation)]]
> - [x] OK
 
## Java
Вопросов в разделе: `= (length(filter(this.file.tasks.section, (h) => meta(h).subpath = "Java")))`

> [!question]- Какая основная идея языка?
> ![[Java#Основной принцип языка Java]]
> - [x] OK

> [!question]- За счет чего обеспечивается кроссплатформенность?
> ![[Java#Кроссплатформенность]]
> - [x] OK

> [!question]- Какие преимущества у JAVA?
> ![[Java#Преимущества Java]]
> - [ ] OK

> [!question]- Какие недостатки у Java?
> ![[Java#Недостатки Java]]
> - [x] OK

> [!question]- Что такое JDK? Что в него входит?
> ![[Java#JDK]]
> - [x] OK

> [!question]- Что такое JRE? что в него входит?
> ![[Java#JRE]]
> - [ ] OK

> [!question]- Что такое JVM?
> ![[Java#JVM]]
> - [x] OK

> [!question]- Что такое byte code?
> ![[Java#Byte Code]]
> - [x] OK

> [!question]- Что такое загрузчик классов (ClassLoader)?
> ![[Java#Class Loader]]
> - [x] OK

> [!question]- Что такое JIT
> ![[Java#JIT]]
> - [ ] OK

> [!question]- Что такое сборщик мусора? (Garbage collector)
> ![[Java#Garbage Collector]]
> - [ ] OK

> [!question]- Что такое Heap и Stack память в Java? Чем они отличаются?
> ![[Java#Структура памяти JVM]]
> - [x] OK
## Процедурная Java
Вопросов в разделе: `= (length(filter(this.file.tasks.section, (h) => meta(h).subpath = "Процедурная Java")))`

> [!question]- Какие примитивные типы данных есть в Java?
> ![[Java Primitive types#Примитивные типы]]
> - [x] OK

> [!question]- Что такое char?
> ![[Java Primitive types#Char]]
> - [x] OK

> [!question]- Сколько памяти занимает boolean?
> В стандартной реализации HotSpot JVM тип boolean занимает 4 байта (32 бита), как и тип int. Однако, в определенных версия JVM имеются реализации, где в массиве boolean каждое значение занимает по 1-му биту.
> Современная архитектура не способна указать адрес памяти в битах, а только в байтах.
> - [x] OK

> [!question]- Что такое классы-обертки?
> Обертка — это специальный класс, который хранит внутри себя значение примитива.
> > [!warning] Обёртки нужны для реализации дженериков.
> 
> Классы-обёртки неизменяемые (Immutable), поэтому при каждой автоупаковке (за исключением значений из pool) создается новый объект, что может привести к неразумному расходу памяти.
> - [x] OK

> [!question]- Что такое автоупаковка и автораспаковка?
> **Автоупаковка** - присвоение классу обертки значения примитивного типа;
> **Автораспаковка** - присвоение переменной примитивного типа значение класса обертки.
> - [x] OK

> [!question]- Что такое явное и неявное приведение типов (иначе называют кастинг)? В каких случаях в java нужно использовать явное приведение?
> Неявное приведение - автоматическое расширение типа переменной от меньшего к большему.
> Явное приведение -  явное сужение от большего к меньшему. Необходимо явно указать сужаемый тип.
> ```java
> double d = 15.1;
long l = (long)d;
int i = (int)l;  
> ```
> В случае с объектами мы можем делать неявное(автоматическое) приведение от наследника к родителю, но не наоборот, иначе получим ClassCastException.
> 
> Расширение приведения (автоматически) – преобразование меньшего типа данных в больший размер типа. byte -> short -> char -> int -> long -> float -> double;
> Сужение приведения (вручную) – преобразование данных большего размера в тип меньшего размера. double -> float -> long -> int -> char -> short -> byte.
> 
> - [x] OK

> [!question]- Что такое пул интов?
> В Java есть пул(pool) целых чисел в промежутке `[-128;127]`, так как это самый часто вречающийся диапазон.
> Т.е. если мы создаем Integer в этом промежутке, то вместо того, чтобы каждый раз создавать новый объект, JVM берет их из пула.
> Изменить размер кэша в HotSpot вы можете, указав ключ` -XX:AutoBoxCacheMax=<размер>`. ( внастройках JVM).
> Пул есть у всех целочисленных, у `Character` и у `Boolean` размер у них менять нельзя.
> Если использовать ключевое слово new, пул не используем, всегда создаем новое значение.
> Физически пул находится в каждом классе оболочке как вложенный статический класс.
> - [x] OK

> [!question]- Какие нюансы у строк в Java?
> **Класс String в Java** - неизменяемый
> - модификатор класса final
> - private поле
> - отсутствие сеттера.
> Это нужно для реализации пула стрингов.
> При редактировании объекта всегда будет создаваться новая строка. 
> При копировании новая строка не создается, а создается ссылка на существующую строку.
> Строковые литералы записываются в **двойных кавычках**.
> - [x] OK

> [!question]- Что такое пул строк?
> **String Pool** – специальный массив для хранения строк в памяти **Heap** (оптимизация).
> При создании в пуле идет поиск строки:
> - если НЕ находит -  создается строка, возращается ссылка;
> - если находит - возращает ссылку найденной строки.
> При этом использование оператора **new** заставляет класс String создать новый объект, даже если такая строка уже есть в пуле. 
> После этого можем использовать метод intern(), чтобы поместить этот объект в пул строк.
> Пул String и Integer хранится в heap, но ссылки на объекты хранятся в stack.
> > [!tip] Пул строк является примером паттерна «Приспособленец(Легковес)» (Flyweight).
> 
> - [ ] OK

> [!question]- Почему не рекомендуется изменять строки в цикле? Что рекомендуется использовать?
> Т.к. строка неизменяемый класс, потребление ресурсов при редактировании, т.к. каждую итерацию при редактировании будет создаваться новый об]ект строки.
> Рекомендуется использовать StringBuilder или StringBuffer.
> - [x] OK

> [!question]- Почему строки не рекомендуется использовать для хранения паролей?
> 1. Так как строки в Java хранятся в пуле строк, то ваш пароль в виде обычного текста будет доступен в памяти, пока сборщик мусора не очистит её. И поскольку String используются в String pool для повторного использования, существует довольно высокая вероятность того, что пароль останется в памяти надолго, что совсем не безопасно.
> 2. Рекомендации авторов Java сама по себе рекомендует использовать метод getPassword() из класса **JPasswordField**, который возвращает char[].
> 3. **Случайная печать в логах.** С типом String всегда существует опасность того, что текст, хранящийся в строке будет напечатан в файле логов или в консоли. В то же время в случае использования Array, вы не будете печатать содержимое массива, а только его расположение в памяти.
> - [x] OK

> [!question]- Почему String неизменяемый и финализированный класс?
> 1. **Для возможности реализации строкового пула (String pool)** Виртуальная машина имеет возможность сохранить много места в памяти (heap space) т.к. разные строковые переменные указывают на одну переменную в пуле. При изменяемости строк было бы невозможно реализовать интернирование, поскольку если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку.
> 2. **Безопасность** Изменяемость строк несло бы в себе потенциальную угрозу безопасности приложения. Поскольку в Java строки используются для передачи параметров для авторизации, открытия файлов и т.д. — неизменяемость позволяет избежать проблем с доступом.
> 3. **Для многопоточности.** Неизменяемые строки потокобезопасны. Так как строка неизменяемая то, она безопасна для многопоточности и один экземпляр строки может быть совместно использован различными потоками. Это позволяет избежать синхронизации для потокобезопасности. Таким образом, строки в Java полностью потокобезопасны.
> 4. **Ключ для HashMap** Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет никакой необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Поэтому строка наиболее часто используется в качестве ключа HashMap.
> - [x] OK

> [!question]- Почему строка является популярным ключом в HashMap в Java?
> Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет никакой необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Поэтому строка наиболее часто используется в качестве ключа HashMap.
> - [x] OK

> [!question]- Что делает метод intern() в классе String?
> Помещает строку в pool строк. Если еще нет в пуле, добавляет и возвращает ссылку. Если уже есть, возвращает ссылку.
> - [x] OK

> [!question]- Можно ли использовать строки в конструкции switch?
> **Да, начиная с Java 7** в операторе switch можно использовать строки, ранние версии Java не поддерживают этого.
> **При этом:**
> - участвующие строки чувствительны к регистру;
> - использование строк в конструкции switch делает код читабельнее, убирая множественные цепи условий if-else;
> - оператор switch использует метод String.equals() для сравнения полученного значения со значениями case, поэтому добавьте проверку на NULL во избежание NullPointerException;
> - согласно документации Java 7 для строк в switch, компилятор Java формирует более эффективный байткод для строк в конструкции switch, чем для сцепленных условий if-else;
> - убедитесь, что это будет использоваться с Java 7 или поздней версии, иначе получите Exception.
> - [ ] OK

> [!question]- Какая основная разница между String, StringBuffer, StringBuilder?
> **String** - неизменяемый, потокобезопасный;
> **StringBuffer** - изменяемый, потокобезопасный;
> **StringBuilder** - изменяемый, потоконебезопасный, более быстрый из-за однопоточности.
> **StringJoiner** - используется, чтобы создать последовательность строк, разделенных разделителем с возможностью присоединить к полученной строке префикс и суффикс:
> ``` java
> StringJoiner joiner = new StringJoiner(".", "prefix-", "-suffix");
> for (String s : "Hello the brave world".split(" ")) {
> 	joiner.add(s);
> }
> System.out.println(joiner); //prefix-Hello.the.brave.world-suffix
> ```
> 
> - [x] OK

> [!question]- Существуют ли в java многомерные массивы?
> Многомерные массивы в их классическом понимании в java не существуют.
> Многомерный массив всегда прямоугольный и неразрывен в памяти.
> А то, что в java считается мнгомерным - в других языках ещё называют "зубчатым массивом" или массивом массивов.
> ``` java
> int[][] a = new int\[3][4];
> ```
> - [x] OK

> [!question]- Какими значениями инициируются переменные по умолчанию?
> Локальные переменные не имеют значений по умолчанию, их имеют поля класса.
> Не static-поле класса будет инициализировано после того, как будет создан объект этого класса.
> А static-поле будет инициализировано тогда, когда класс будет загружен виртуальной Java машиной.
> ![[Java Primitive types#Значения по умолчанию]]
> 
> - [x] OK

> [!question]- Что такое сигнатура метода?
> Это имя метода плюс параметры (порядок параметров имеет значение из-за множественной передачи данных через троеточие, которое должно располагаться последним).
> В сигнатуру метода не входит возвращаемое значение, а также бросаемые им исключения.
> А сигнатура метода в сочетании с типом возвращаемого значения и бросаемыми исключениями называется контрактом метода.
> - [x] OK

> [!question]- Расскажите про метод main
> Является, как правило, точкой входа в программу и вызывается JVM.
> Как только заканчивается выполнение метода main(), так сразу же завершается работа самой программы.
> **static** - чтобы JVM смогла загрузить его во время компиляции.
> **public static void и сигнатура** - обязательное декларирование.
> Мэйнов может быть много и может не быть вообще. Может быть **перегружен**.
> - [x] OK

> [!question]- Каким образом переменные передаются в методы, по значению или по ссылке?
> Java передает параметры по значению. Всегда. С примитивами, мы получаем копию содержимого. Со ссылками мы тоже получаем копию ссылки.
> - [x] OK
## ООП в Java
Вопросов в разделе: `= (length(filter(this.file.tasks.section, (h) => meta(h).subpath = "ООП в Java")))`

> [!question]- Какие виды классов есть в java?
> ![[Class#Виды классов в Java]]
> - [x] OK

> [!question]- Расскажите про вложенные классы. В каких случаях они применяются?
> ![[Class#Вложенные классы]]
> - [x] OK

> [!question]- Что такое «локальный класс»? Каковы его особенности?
> ![[Class#Local Inner Class]]
> - [x] OK

> [!question]- Что такое «анонимные классы»? Где они применяются?
> ![[Class#Anonymous inner class]]
> - [ ] OK

> [!question]- Каким образом из вложенного класса получить доступ к полю внешнего класса?
> ![[Class#Доступ к полям внешнего класса]]
> - [x] OK

> [!question]- Что такое перечисления (enum)?
> ![[Enum]]
> - [ ] OK

> [!question]- Как проблема ромбовидного наследования решена в java?
> В Java нет поддержки множественного наследования классов.
> Предположим, что SuperClass — это абстрактный класс, описывающий некоторый метод, а классы ClassA и ClassB — обычные классы наследники SuperClass, а класс ClassC наследуется от ClassA и ClassB одновременно. Вызов метода родительского класса приведет к неопределенности, так как компилятор не знает о том, метод какого именно суперкласса должен быть вызван. Это и есть основная причина, почему в Java нет поддержки множественного наследования классов.
> 1. **Классы всегда побеждают**: Определенный в классе / суперклассе метод всегда имеет высший приоритет перед дефолтными методами интерфейсов.
> 2. **Если не срабатывает правило 1, то побеждают саб-интерфейсы** (more specific). Т.е. если интерфейс B наследует A, и у обоих есть методы с одинаковой сигнатурой, то побеждает B.
> 3. **Если оба правила не работают**, то класс, наследующий конфликтующие интерфейсы, должен явно через super определить, какой именно метод вызвать.
> - [x] OK

> [!question]- Что такое конструктор по умолчанию?
> Если у какого-либо класса не определить конструктор, то компилятор сгенерирует конструктор без аргументов - так называемый «конструктор по умолчанию».
> Если у класса уже определен какой-либо конструктор, то конструктор по умолчанию создан не будет и, если он необходим, его нужно описывать явно.
> - [x] OK

> [!question]- Могут ли быть приватные конструкторы? Для чего они нужны?
> Да, могут. Приватный конструктор запрещает создание экземпляра класса вне методов самого класса, чтобы гарантировать существование только одного объекта определённого класса, предположим какого-то ресурса, например БД.
> Нужен для реализации паттернов, например singleton.
> - [x] OK

> [!question]- Расскажите про классы-загрузчики и про динамическую загрузку классов.
> ![[Java#Class Loader#Классы загрузчики]]
>![[Java#Class Loader#Динамическая загрузка]]
> - [ ] OK

> [!question]- Чем отличаются конструкторы по умолчанию, конструктор копирования и конструктор с параметрами?
> У конструктора по умолчанию отсутствуют какие-либо аргументы.
> Конструктор копирования принимает в качестве аргумента уже существующий объект класса для последующего создания его клона.
> Конструктор с параметрами имеет в своей сигнатуре аргументы (обычно необходимые для инициализации полей класса).
> - [x] OK

> [!question]- Какие модификаторы доступа есть в Java? Какие применимы к классам?
> ![[Modifiers#Модификаторы доступа]]
> - [ ] OK

> [!question]- Модификаторы для переменных / Модификаторы для методов. Что означает модификатор static?
> ![[Modifiers#final]]
> ![[Modifiers#static]]
> ![[Modifiers#abstract]]
> - [x] OK

> [!question]- Может ли статический метод быть переопределён или перегружен?
> > [!error] Нельзя переопределять статические методы.
> Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса вместо переопределения. Это явление известно как сокрытие методов (hiding methods).
> 
> **Перегружен - да.** Всё работает точно так же как и с обычными методами - 2 статических метода могут иметь одинаковое имя, если количество их параметров или типов различается.
> - [x] OK

> [!question]- Могут ли нестатические методы перегрузить статические?
> Да. Это будут просто два разных метода для программы. Статический будет доступен по имени класса.
> - [ ] OK

> [!question]- Можно ли сузить уровень доступа/тип возвращаемого значения при переопределении метода?
> При переопределении метода нельзя сузить модификатор доступа к методу (например, с public до private), но можно расширить.
> 
> Изменить тип возвращаемого значения нельзя, но можно сузить возвращаемое значение, если они совместимы. Например если метод возвращает объект класса, а переопределенный метод возвращает класс-наследник.
> 
> - [x] OK

> [!question]- Что можно изменить в сигнатуре метода при переопределении? Можно ли менять модификаторы (throws и тп)?
> > [!error] В сигнатуре(имя + параметры) менять ничего нельзя.
> 
> - Возможно расширение уровня доступа.
> - Возможно изменить тип возвращаемого значения в сторону **сужения** типа (вместо родительского класса - наследника).
> - Возможно изменить имя аргумента.
> 
> **Секцию throws** метода можно не указывать, но стоит помнить, что она остаётся действительной, если уже определена у метода родительского класса.
> Также, возможно добавлять новые исключения, являющиеся наследниками от уже объявленных или исключения RuntimeException. Порядок следования таких элементов при переопределении значения не имеет.
> - [x] OK

> [!question]- Могут ли классы быть статическими?
> Класс можно объявить статическим за исключением классов верхнего уровня.
> Такие классы известны как «вложенные статические классы» (nested static class).
> - [x] OK

> [!question]- Что означает модификатор final? К чему он может быть применим?
> ![[Modifiers#final]]
> - [ ] OK

> [!question]- Что такое абстрактные классы? Чем они отличаются от обычных?
> ![[Class#Abstract Class]]
> - [ ] OK

> [!question]- Может ли быть абстрактный класс без абстрактных методов?
> Класс может быть абстрактным без единого абстрактного метода, если у него указан модификатор abstract.
> - [ ] OK

> [!question]- Могут ли быть конструкторы у абстрактных классов? Для чего они нужны?
> **Да**. Необходимы для наследников.
> В абстрактном классе в Java можно объявить и определить конструкторы. Даже если вы не объявили никакого конструктора, компилятор добавит в абстрактный класс конструктор по умолчанию без аргументов. Абстрактные конструкторы будут часто использоваться для обеспечения ограничений класса или инвариантов, таких как минимальные поля, необходимые для настройки класса.
> - [x] OK

> [!question]- Что такое интерфейсы? Какие модификаторы по умолчанию имеют поля и методы интерфейсов?
> ![[Interface]]
> - [x] OK

> [!question]- Чем интерфейсы отличаются от абстрактных классов? В каких случаях следует использовать абстрактный класс, а в каких интерфейс?
> - Интерфейс описывает только поведение (методы) объекта, а вот состояний (полей) у него нет (кроме public static final), в то время как у абстрактного класса они могут быть.
> - Мы можем наследовать только один класс, а реализовать интерфейсов — сколько угодно. Интерфейс может наследовать (extends) другой интерфейс/интерфейсы.
> - Абстрактные классы используются, когда есть отношение "is-a", то есть класс-наследник расширяет базовый абстрактный класс, а интерфейсы могут быть реализованы разными классами, вовсе не связанными друг с другом.
> - Абстрактный класс может реализовывать методы; интерфейс может реализовывать статические методы начиная с 8й версии.
> - [x] OK

> [!question]- Может ли один интерфейс наследоваться от другого? От двух других?
> Да, может. Используется ключевое слово `extends`.
> - [x] OK

> [!question]- Что такое дефолтные методы интерфейсов? Для чего они нужны?
> ![[Interface#default methods]] 
> - [x] OK

> [!question]- Как решается проблема ромбовидного наследования при наследовании интерфейсов при наличии default методов?
> Класс, наследующий конфликтующие интерфейсы, должен явно через super определить, какой именно метод вызвать: `InterfaceB.super.method();`
> - [x] OK

> [!question]- Каков порядок вызова конструкторов и блоков инициализации с учетом иерархии классов?
> 1. (static) Parent static block(s) → Child static block(s) → Grandchild static block(s)
> 2. (non static) Parent non-static block(s) → Parent constructor → → Child non-static block(s) → Child constructor → → Grandchild non-static block(s) → Grandchild constructor.
> - [ ] OK

> [!question]- Зачем нужны и какие бывают блоки инициализации?
> **Инициализация** - это когда мы впервые задаем переменной какое-либо значение.
> Без присвоения начального значения переменная просто объявлена, а с начальным значением она еще и инициализирована.
> 
> Существуют статические и нестатические блоки инициализации.
> 
> Блок инициализации выполняется перед инициализацией класса загрузчиком классов или созданием объекта класса с помощью конструктора.
> Несколько блоков инициализации выполняются в порядке следования в коде класса.
> 
> Блок инициализации способен генерировать исключения, если их объявления перечислены в throws всех конструкторов класса.
> - [x] OK

> [!question]- Для чего в Java используются статические блоки инициализации?
> **Статические блоки** инициализация используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов, в момент предшествующий созданию объектов этого класса при помощи конструктора.
> 
> Такой блок принадлежит только самому классу.
> - [x] OK

> [!question]- Что произойдет, если в блоке инициализации возникнет исключительная ситуация?
> Для нестатических блоков инициализации, если выбрасывание исключения прописано явным образом, требуется, чтобы объявления этих исключений были перечислены в throws всех конструкторов класса. Иначе будет ошибка компиляции.
> > [!error] Для статического блока выбрасывание исключения в явном виде, приводит к ошибке компиляции.
> 
> - [ ] OK

> [!question]- Какое исключение выбрасывается при возникновении ошибки в блоке инициализации класса?
> Если возникшее исключение - наследник `RuntimeException`:
> - для статических блоков инициализации будет выброшено `ExceptionInInitializerError`
> - для нестатических будет проброшено исключение-источник
> Если возникшее исключение - наследник `Error`, то в обоих случаях будет выброшено `java.lang.Error`.
> - [x] OK

> [!question]- Что такое класс Object?
> Базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и, соответственно, наследуют его методы.
> Все классы являются наследниками суперкласса Object. Это не нужно указывать явно. В результате объект Object может ссылаться на объект любого другого класса.
> **Рефлексия** (от позднелат. reflexio - обращение назад) - это механизм исследования данных о программе во время её выполнения.
> - [x] OK

> [!question]- Что такое класс Class?
> В Java все объекты являются экземплярами какого-либо класса. И сами классы являются также объектами. Так вот объекты-классы являются экземплярами класса Class.
> - [x] OK

> [!question]- Какие методы есть у класса Object (перечислить все)? Что они делают?
> - **equals()** - проверка на равенство двух обьектов;
> - **hashCode()** - изначально случайно число int;
> - **toString()** - представления данного объекта в виде строки;
> - **getClass()** - получение типа данного обьекта;
> - **clone()** - клонирует объект методом;
> - **finalize()** - deprecated, вызывается GC перед удалением. (нет гарантии что будет вызван);
> Для многопоточки:
> - **notify()** - «размораживает» одну случайную нить;
> - **notifyAll()** - «размораживает» все нити данного монитора;
> - **wait()** - нить освобождает монитор и «становится на паузу»;
> - **wait(long timeOut)** - нить освобождает монитор и «становится на паузу»,принимает максимальное время ожидания в миллисекундах;
> - **wait(long timeOut, int nanos)** - нить освобождает монитор и «становится на паузу»,принимает максимальное время ожидания в миллисекундах, дополнительное время, в диапазоне наносекунд 0-999999.
> - [x] OK

> [!question]- Расскажите про equals и hashcode
> ![[equals and hashcode]]
> - [x] OK

> [!question]- Каким образом реализованы методы hashCode() и equals() в классе Object?
> 1. Реализация метода `Object.equals()` сводится к проверке на равенство двух ссылок:
> ``` java
> public boolean equals(Object obj) {
> 	return (this == obj); 
> }
> ```
> 2.  `HashCode` реализован таким образом, что для одного и того же входного объекта, хеш-код всегда будет одинаковым. Реализация метода `Object.hashCode()` описана как native, т.е. написана не на Java.
> 	Конкретная реализация зависит от версии Java
> - [ ] OK

> [!question]- Зачем нужен equals(). Чем он отличается от операции \== ?
> **equals()** - сравнение по состоянию,
> **\==** -  по ссылкам.
> - [x] OK

> [!question]- Правила переопределения equals()
> ![[equals and hashcode#@Override Equals]]
> - [ ] OK

> [!question]- Что будет, если переопределить equals() не переопределяя hashCode()? Какие могут возникнуть проблемы?
> Нарушится контракт.
> Классы и методы, которые использовали правила этого контракта могут некорректно работать.
> Так для объекта HashMap это может привести к тому, что пара, которая была помещена в Map возможно не будет найдена в ней при обращении к Map, если используется новый экземпляр ключа.
> - [x] OK

> [!question]- Какой контракт между hashCode() и equals()?
> ![[equals and hashcode#**Контракт equals и hashcode **]]
> - [ ] OK

> [!question]- Для чего нужен метод hashCode()?
> Вычисляет целочисленное значение для конкретного элемента класса, чтобы использовать его для быстрого поиска и доступа к этому элементу в hash-структурах данных, например, HashMap, HashSet и прочих.
> - [x] OK

> [!question]- Правила переопределения метода hashСode()
> Если хеш-коды разные, то и входные объекты гарантированно разные.
> Если хеш-коды равны, то входные объекты не всегда равны.
> При вычислении хэш-кода следует использовать те же поля, которые сравниваются в equals и которые не вычисляются на основе других значений.
> - вызов метода hashCode один и более раз над одним и тем же объектом должен возвращать одно и то же хэш-значение, при условии что поля объекта, участвующие в вычислении значения, не изменялись.
> - вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода equals для этих объектов возвращает true).
> - вызов метода hashCode над двумя неравными между собой объектами должен возвращать разные хэш-значения. Хотя это требование и не является обязательным, следует учитывать, что его выполнение положительно повлияет на производительность работы хэш-таблиц.
> - [ ] OK

> [!question]- Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?
> Выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо использовать уникальные, лучше всего примитивные поля, например такие как id, uuid. При этом нужно следовать правилу
> > [!warning] если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals()
> 
> - [x] OK

> [!question]- Могут ли у разных объектов быть одинаковые hashCode()?
> Когда у разных объектов одинаковые хеш-коды называется — коллизией.
> - [x] OK

> [!question]- Почему нельзя реализовать hashcode() который будет гарантированно уникальным для каждого объекта?
> В Java множество возможных хэш кодов ограничено типом int, а множество объектов ничем не ограничено. Из-за этого, вполне возможна ситуация, что хэш коды разных объектов могут совпасть.
> Хэшкод может быть и отрицательным!
> - [x] OK

> [!question]- Есть класс Point {int x, y;} Почему хэш-код в виде 31 * x + y предпочтительнее чем x + y?
> Множитель создает зависимость значения хэш-кода от очередности обработки полей, а это дает гораздо лучшую хэш-функцию.
> > [!tip] Почему 31?
> > Это связано с тем, что число 31 имеет хорошее свойство — его умножение можно заменить побитовым сдвигом, который выполняется быстрее, чем стандартное умножение: 31 * i == (i << 5) - i
> 
> - [x] OK

> [!question]- Чем a.getClass().equals(A.class) отличается от a instanceof A.class
> getClass() получает только класс, а оператор instanceof проверяет является ли объект экземпляром класса или его потомком.
> - [x] OK
## Исключения
Вопросов в разделе: `= (length(filter(this.file.tasks.section, (h) => meta(h).subpath = "Исключения")))`

> [!question]- Что такое исключения?
> ![[Exception#Exception]]
> - [x] OK

> [!question]- Опишите иерархию исключений.
> ![[Exception#Hierarchy]]
> - [x] OK

> [!question]- Расскажите про обрабатываемые и необрабатываемые исключения
> ![[Exception#Checked / Unchecked]]
> - [x] OK

> [!question]- Можно ли обработать необрабатываемые исключения?
> Обрабатывать можно, но делать этого не стоит, так как это ошибка в коде разработчика.
> **Error не обрабатывается**. Разработчику не предоставлены инструменты для обработки ошибок системы и виртуальной машины.
> - [x] OK

> [!question]- Какой оператор позволяет принудительно выбросить исключение?
> ```java
> throw new Exception...
> ```
> - [x] OK

> [!question]- О чем говорит ключевое слово throws?
> Метод потенциально может выбросить исключение с указанным типом. Передаёт обработку исключения вышестоящему методу.
> - [x] OK

> [!question]- Как создать собственное («пользовательское») исключение?
> Необходимо унаследоваться от базового класса требуемого типа исключений (например, от Exception или RuntimeException). И переопределить методы.
> - [x] OK

> [!question]- Расскажите про механизм обработки исключений в java (Try-catch-finally)
> **Try** - блок в котором может появиться исключение;
> **Catch** - блок в котором мы указываем исключение и логику его обработки;
> **Finally** - блок который обязательно отработает(обычно блок освобождает ресурсы).
> Блок **finally** всегда выполняется после кода в предыдущем блоке **try**.
> Оператор **finallу** образует блок кода, который будет выполнен по завершении блока операторов try-catch, но перед следующим за ним кодом.
> - [x] OK

> [!question]- Возможно ли использование блока try-finally (без catch)?
> **try** может быть в паре с **finally**, без **catch**.
> Работает это точно так же - после выхода из блока try выполняется блок finally.
> - [x] OK

> [!question]- Может ли один блок catch отлавливать сразу несколько исключений?
> **Да**.
> В порядке от частного случая к общему(от потомка к родителю).
> - [x] OK

> [!question]- Всегда ли выполняется блок finally? Существуют ли ситуации, когда блок finally не будет выполнен?
> **Да, кроме случаев завершения работы программы или JVM**:
> - Finally может не выполниться в случае если в блоке try вызывает System.exit(0),
> - Runtime.getRuntime().exit(0), Runtime.getRuntime().halt(0) и если во время исполнения блока try виртуальная машина выполнила недопустимую операцию и будет закрыта.
> - В блоке try{} бесконечный цикл.
> - [ ] OK

> [!question]- Может ли метод main() выбросить исключение во вне и если да, то где будет происходить обработка данного исключения?
> **Может** и оно будет передано в виртуальную машину Java (JVM).
> Для случая с методом main произойдет две вещи:
> - будет завершен главный поток приложения;
> - будет вызван ThreadGroup.uncaughtException.
> - [x] OK

> [!question]- В каком порядке следует обрабатывать исключения в catch блоках?
> > [!warning] От наследника к предку. От частного к общему (родителю).
> 
> Когда используются множественные операторы catch, важно помнить, что подклассы исключений должны следовать перед любыми их суперклассами (родителями). Это потому, что оператор catch, который использует суперкласс, будет перехватывать все исключения этого суперкласса плюс всех его подклассов.
> - [x] OK

> [!question]- Что такое механизм try-with-resources?
> Механизм дает возможность объявлять один или несколько ресурсов в блоке try, которые будут закрыты автоматически без использования finally блока.
> В качестве ресурса можно использовать любой объект, класс которого реализует интерфейс `java.lang.AutoCloseable` или `java.io.Closeable.` try-catch с ресурсами (спец. конструкция) – это улучшенное управление ресурсами, которые должны быть закрыты после окончания работы с ними. Избавляет разработчиков от обязанности освобождать ресурсы, используемые в блоке try.
> Кроме того, код, использующий try-with-resources, часто является более чистым и читаемым, что облегчает управление кодом. Для того чтобы это автоматическое закрытие работало создан специальный интерфейс `AutoCloseable`.
> Ресурсы создаются только в блоке try. В какой момент закрываются ресурсы? При выходе из блока try. Важно: ресурсы закрываются в обратном порядке объявления
> - [x] OK

> [!question]- Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из блока finally?
> finally-секция может «перебить» throw/return при помощи другого throw/return - увидим последнее исключение.
> - [x] OK

> [!question]- Что произойдет если исключение будет выброшено из блока catch после чего другое исключение будет выброшено из метода close() при использовании try-with-resources?
> В try-with-resources добавленна возможность хранения "подавленных" исключений, и брошенное try-блоком исключение имеет больший приоритет, чем исключения, получившиеся во время закрытия. Подавленные исключения (suppressed exception) образуются, когда в блоке try генерируется исключение и в методе close(). При закрытии ресурса генерируется исключение, в этом случае ПЕРВОЕ исключение считается ГЛАВНЫМ остальные ПОДАВЛЕННЫЕ.
> - [x] OK
## Сериализация и копирование
Вопросов в разделе: `= (length(filter(this.file.tasks.section, (h) => meta(h).subpath = "Сериализация и копирование")))`

> [!question]- Что такое сериализация и как она реализована в Java?
> **Сериализация** это процесс сохранения состояния объекта в последовательность байт (сохранение в поток для дальнейшего использования или хранения этого объекта);
> Реализована через интерфейс - маркер **Serializable**.
> - [x] OK

> [!question]- Для чего нужна сериализация?
> Для компактного сохранения состояния объекта и считывание этого состояния.
> - [x] OK

> [!question]- Опишите процесс сериализации/десериализации с использованием Serializable.
> 1. Класс объекта должен реализовывать интерфейс `Serializable`
> 2. Создать поток `ObjectOutputStream` (oos), который записывает объект в переданный `OutputStream`.
> 3. Записать в поток: `oos.writeObject(Object)`;
> 4. Сделать `oos.flush()` и `oos.close()` (очистить буфер и закрыть)
> 
> **4 этапа записи**:
> 1. записываются метаданные;
> 2. рекурсивно записывается информация (описание классов) от родителя до наследника;
> 3. примитивы записываются;
> 4. пишутся в поток.
> - [x] OK

> [!question]- Как изменить стандартное поведение сериализации/десериализации?
> - Использовать интерфейс Externalizable.
> - Переопределить методы 
> `writeExternal(ObjectOutput out) throws IOException`
>` readExternal(ObjectInput in) throws IOException, ClassNotFoundException`
> - [ ] OK

> [!question]- Какие поля не будут сериализованы при сериализации? Будет ли сериализовано final поле?
> 1. Добавить к полю модификатор transient. В таком случае после восстановления его значение будет null.
> 2. Сделать поле static. Значения статических полей автоматически не сохраняются.
> 3. Поля с модификатором final сериализуются как и обычные. За одним исключением – их невозможно десериализовать при использовании Externalizable, поскольку final-поля должны быть инициализированы в конструкторе, а после этого в readExternal изменить значение этого поля будет невозможно. Соответственно, если необходимо сериализовать объект с final-полем неоходимо использовать только стандартную сериализацию.
> > [!tip] Аннотация @Transient с сериализацией не связана и указывает, что поля не должны сохраняться в базе данных.
> 
> - [x] OK

> [!question]- Какая роль поля serialVersionUID в сериализации?
> Поле private static final long `serialVersionUID` содержит уникальный идентификатор версии сериализованного класса. Оно вычисляется по содержимому класса - полям, их порядку объявления, методам, их порядку объявления. Соответственно, при любом изменении в классе это поле поменяет свое значение. Поле `serialVersionUID` так же записывается при сериализации.
> > [!info] Если мы не объявляем `serialVersionUID` явно, Java делает это за нас.
> 
> Руками нужно менять, чтобы программист сам понимал, являются ли изменения обратно-совместимыми или нет.
> Если что-то изменил и это обратно-совместимо, версию `serialVersionUID` менять НЕ нужно, а если изменил и это обратно-НЕ совместимо, то нужно поменять версию.
> - [ ] OK

> [!question]- Когда стоит изменять значение поля serialVersionUID?
> Вы должны изменить `serialVersionUID` только тогда, когда вы сознательно хотите нарушить совместимость со всеми существующими сериализациями, например, когда изменения в вашем классе сделают его настолько семантически отличным, что у вас не будет выбора - в этом случае вы действительно должны несколько раз подумать о том, что вы на самом деле делаете.
> - [ ] OK

> [!question]- В чем проблема сериализации Singleton?
> Проблема в том что после десериализации мы получим другой объект.
> Таким образом, сериализация дает возможность создать `Singleton` еще раз, что не совсем нужно.
> > [!tip] **Решение**:
> В классе определяется метод с сигнатурой `Object readResolve() throws ObjectStreamException`
> 
> Назначение этого метода - возвращать замещающий объект вместо объекта, на котором он вызван.
> - [x] OK

> [!question]- Расскажите про клонирование объектов.
> В Java, есть 3 способа клонирования объекта:
> 1. **С использованием интерфейса Cloneable**;
> Первый способ подразумевает, что вы будете использовать механизм так называемого «поверхностного клонирования» и сами позаботитесь о клонировании полей-объектов. Метод `clone()` в родительском классе `Object` является `protected`, поэтому требуется переопределение его с объявлением как `public`. Он возвращает экземпляр объекта с копированными полями-примитивами и ссылками. И получается что у оригинала и его клона поля-ссылки указывают на одни и те же объекты.
> 2. **С использованием конструктора клонирования объекта**;
> В классе описывается конструктор, который принимает объект этого же класса и инициализирует значениями его полей поля нового объекта.
> 3. **С использованием сериализации**.
> Он заключается в сохранении объекта в поток байтов с последующей эксгумацией его от туда.
> 4. **С использованием паттерна Прототип** (в этом блоке не обязательно знать).
> - [ ] OK

> [!question]- В чем отличие между поверхностным и глубоким клонированием?
> **Поверхностное копирование** копирует настолько малую часть информации, насколько это возможно.
> По умолчанию, клонирование в Java является поверхностным, т.е. Object class не знает о структуре класса, которого он копирует.
> При поверхностном клонируются ссылки, а не объекты.
> **Глубокое копирование** дублирует все. **Глубокое копирование** - это две коллекции, в одну из которых дублируются все элементы оригинальной коллекции.
> - [x] OK

> [!question]- Какой способ клонирования предпочтительней?
> Наиболее безопасным и следовательно предпочтительным способом клонирования является использование специализированного конструктора копирования:
> - Отсутствие ошибок наследования (не нужно беспокоиться, что у наследников появятся новые поля, которые не будут склонированы через метод clone());
> - Поля для клонирования указываются явно;
> - Возможность клонировать даже final поля.
> - [ ] OK

> [!question]- Почему метод clone() объявлен в классе Object, а не в интерфейсе Cloneable?
> Метод clone() объявлен в классе Object с сигнатурой **native**, чтобы обеспечить доступ к стандартному механизму "поверхностного копирования" объектов (копируются значения всех полей, включая ссылки на сторонние объекты);
> Он объявлен, как protected, чтобы нельзя было вызвать этот метод у не переопределивших его объектов.
> - [ ] OK

> [!question]- Как создать глубокую копию объекта? (2 способа)
> 1. С помощью метода `clone()` при выполнении следующих правил:
> 	- Нет необходимости копировать отдельно примитивные данные;
> 	- Все классы-члены в оригинальном классе должны поддерживать клонирование. Для каждого члена класса должен вызываться `super.clone()` при переопределении метода `clone()`;
> 	- Если какой-либо член класса не поддерживает клонирование, то в методе клонирования необходимо создать новый экземпляр этого класса и скопировать каждый его член со всеми атрибутами в новый объект класса, по одному.
> 2. Сериализация – это еще один способ глубокого копирования. Мы просто сериализуем нужный объект и десериализуем его. Очевидно, объект должен поддерживать интерфейс `Serializable`. Мы сохраняет объект в массив байт, чтобы потом прочитать из него.
> 3. При помощи библиотеки `DeepCloneable`.
> 4. Строронние библиотеки:
> - [ ] OK
