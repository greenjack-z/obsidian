**Интерфейс** является контрактом, определяющим поведение объекта.

В интерфейсе каждый метод является открытым и абстрактным, но не содержит конструктора. Таким образом, интерфейс в основном представляет собой группу связанных методов с пустыми телами. Другими словами, интерфейс определяет как элементы будут взаимодействовать между собой.

- **методы интерфейса** являются публичными (public) и абстрактными (abstract), но без явного обозначения;
- **поля** — public static final, без явного указания, доступны для всех кто имплементирует интерфейс.

**Интерфейсы маркеры** – это интерфейсы, у которых не определены ни методы, ни переменные. Реализация этих интерфейсов придает классу определенные свойства.

### default methods
В **JDK 8** была добавлена такая функциональность как методы по умолчанию с модификатором default. И теперь интерфейсы могут иметь их реализацию по умолчанию, которая используется, если класс, реализующий данный интерфейс, не реализует метод. Это нужно для обратной совместимости.
> [!tip] Если один или несколько методов добавляются к интерфейсу, все реализации также будут вынуждены их реализовывать. Методы интерфейса по умолчанию являются эффективным способом решения этой проблемы.

С приходом Java 9 стало возможным создание приватных методов в интерфейсах, делая их логическим продолжением default и static методов. Зачем нужны еще и приватные методы? К примеру, поддержание cleancode посредством вынесения общей логики default и static методов в приватные.

Как вызывать default метод интерфейса в реализующем этот интерфейс классе? Используя ключевое слово `super` вместе с именем интерфейса: `Paper.super.show();`

Статические методы в интерфейсе используются для обеспечения вспомогательных методов, например, проверки на `null`, сортировки коллекций и т.д.

Как вызывать `static` метод интерфейса? Используя имя интерфейса: `Paper.show();`