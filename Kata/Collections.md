---
tags:
  - kata
  - java
  - core
  - oop
---
## Collection
Для хранения наборов данных в Java предназначены массивы. Однако их не всегда удобно использовать, прежде всего потому, что они имеют фиксированную длину. Кроме того, у массивов нет никакой защиты от изменений.
Эту проблему в Java решают коллекции.
**Коллекции** – это "контейнер" или группа, т.е. совокупность объектов, которые мы храним вместе. Или так: **коллекции** — это наборы однородных элементов (например, страницы в книге, яблоки в корзине или люди в очереди).
Инструменты для работы с такими структурами в Java содержатся в `Java Collections Framework`, классы коллекций располагаются в пакете `java.util` 
Классы коллекций являются [[Generics|дженериками]] и параметризируются типом хранимых внутри элементов. В качестве значения дженерик параметра может использоваться только ссылочный тип, поэтому все коллекции в java работают со ссылочными типами.

## Иерархия коллекций
![[Pasted image 20230925130239.png|600]]
**Iterator** – это объект с состоянием итерации. Он позволяет проверить, есть ли еще элементы, используя `hasNext()`, и перейти к следующему элементу (если есть), используя `next()`. Так же есть метод `remove()` – удалить во время обхода элемент коллекции.

Методы, которые есть в `Collection`, будут и во всех классах-наследниках (которые его имплементируют):
- add() - для добавления элементов
- remove() - для удаления элементов
- size() - проверка размера коллекции
- isEmpty() - проверка пуста ли коллекция или нет
Удаление элемента из коллекции не влечет фактического освобождения памяти. Память освобождает GarbageCollector.

**Интерфейс Collection расширяют интерфейсы:**
### **List** (список) 
представляет собой коллекцию, в которой допустимы дублирующие значения. Элементы такой коллекции пронумерованы, начиная от нуля, к ним можно обратиться по индексу. **Реализации**:
- **ArrayList** - инкапсулирует в себе обычный массив, длина которого автоматически увеличивается при добавлении новых элементов.
- **LinkedList** (двунаправленный связный список) - состоит из узлов, каждый из которых содержит как собственно данные, так и две ссылки на следующий и предыдущий узел.
- **Vector** — реализация динамического массива объектов, методы которой синхронизированы (доступны по очереди, т.е. может использовать кто-то один).
- **Stack** — реализация стека LIFO (last-in-first-out).
### **Set** (сет)
описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов.
**Реализации**:
- **HashSet** - использует HashMap для хранения данных. В качестве ключа и значения используется добавляемый элемент. Из-за особенностей реализации порядок элементов не гарантируется при добавлении.
- **LinkedHashSet** — гарантирует, что порядок элементов при обходе коллекции будет идентичен порядку добавления элементов.
- **(SortedSet) TreeSet** — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».
### **Queue** (очередь)
предназначена для хранения элементов с предопределённым способом вставки и извлечения FIFO (first-in-first-out):
- **PriorityQueue** — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».
- **ArrayDeque** — реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими реализовать конструкцию вида LIFO (last-infirst-out).

### **Интерфейс Map реализован классами**:
- **Hashtable** — хэш-таблица, методы которой синхронизированы. Не позволяет использовать null в качестве значения или ключа и не является упорядоченной.
- **HashMap** — хэш-таблица. Позволяет использовать null в качестве значения или ключа и не является упорядоченной.
- **LinkedHashMap** — упорядоченная реализация хэш-таблицы.
- **TreeMap** — реализация, основанная на красно-чёрных деревьях. Является упорядоченной и предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».
- **WeakHashMap** — реализация хэш-таблицы, которая организована с использованием weak references для ключей (сборщик мусора автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элемента нет жёстких ссылок).

## Почему Map — это не Collection
в то время как List и Set являются Collection?

Коллекция (**List и Set**) представляет собой совокупность некоторых элементов (обычно экземпляров одного класса).

**Map** - это совокупность пар "ключ"-"значение". Такие коллекции облегчают поиск элемента, если нам известен ключ - уникальный идентификатор объекта.
Соответственно некоторые методы интерфейса Collection нельзя использовать в Map.
Например, метод `remove(Object o)` в интерфейсе Collection предназначен для удаления элемента, тогда как такой же метод `remove(Object key)` в интерфейсе Map - удаляет элемент по заданному ключу.

У Map нет Iterable, не понятно по чему проводить итерацию.

## В чем разница между классами java.util.Collection и java.util.Collections?
`java.util.Collections` - это класс, который содержит исключительно статические методы для работы с коллекциями.
В них входят методы, реализующие полиморфные алгоритмы (такие алгоритмы, использование которых возможно с разными видами структур данных), "оболочки", возвращающие новую коллекцию с инкапсулированной указанной структурой данных и некоторые другие методы.
Все методы этого класса вызывают исключение NullPointerException, если предоставленные им коллекции или объекты класса имеют значение null.
[collections](https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html)

`java.util.Collection` - это корневой интерфейс Java Collections Framework. Этот интерфейс в основном применяется там, где требуется высокий уровень абстракции, например, в классе java.util.Collections. Этот интерфейс обычно используется для передачи коллекций и управления ими там, где требуется максимальная универсальность.
[collection](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html)

## Какая разница между итераторами с fail-fast и fail-safe поведением?
- Итератор **fail-safe** не вызывает исключений при изменении структуры коллекции, потому что работает с её клоном.
	Пример **fail-safe** - CopyOnWriteArrayList (он создает отдельную копию) и итератор (keySet коллекции ConcurrentHashMap - не создает отдельную копию).
	Еще пример fail-safe - Vector и Hashtable, Stack.

- Итератор **fail-fast** генерирует исключение ConcurrentModificationException, если коллекция меняется во время итерации, но работает быстрее.
## Чем различаются Enumeration и Iterator?
Это два интерфейса в пакете `java.util` используются для обхода элементов коллекции. Хотя они выполняют одну и ту же функцию, между ними существуют некоторые различия. Используя `Enumeration`, вы можете только перемещаться по коллекции, а с помощью Итератора можете также удалить элемент при обходе коллекции. Методы – это основное различие между интерфейсами `Enumeration` и `Iterator`. Можно сказать, что `Iterator` – это расширенная версия `Enumeration`.

**Enumeration** — это устаревший интерфейс, используемый для обхода только устаревших классов, таких как Vector, HashTable и Stack.

**Итератор** является «быстрым» fail-fast итератором, то есть будет выброшено исключение ConcurrentModificationException, если коллекция изменится во время итерации с применением собственного метода remove(). Напротив, Enumeration не выбросит никаких исключений, даже если коллекция изменяется во время итерации.

> [!question] Как избежать ConcurrentModificationException во время перебора коллекции?
> - Попробовать подобрать другой итератор, работающий по принципу fail-safe. К примеру, для List можно использовать ListIterator.
> - Использовать ConcurrentHashMap и CopyOnWriteArrayList
> - Преобразовать список в массив и перебирать массив
> - Блокировать изменения списка на время перебора с помощью блока synchronized 
> 
> Отрицательная сторона последних двух вариантов – это ухудшение производительности

## Как между собой связаны Iterable, Iterator и «for-each»?
- Interface `Iterable<T>` – это интерфейс, который реализуют коллекции, у него есть метод `iterator`, который возвращает объект Итератор по элементам типа T.
- `Iterator` — объект с состоянием итерации (бегунок, курсор, указатель). Он позволяет проверить, есть ли еще больше элементов, используя `hasNext()`, и перейти к следующему элементу (если есть), используя `next()`. Так же есть метод `remove()`.
- `forEach` — это разновидность цикла `for`, метод интерфейса `Iterable`. Выполняет заданное действие для каждого элемента Iterable до тех пор, пока все элементы не будут обработаны или действие не вызовет исключение.
```java
default void forEach(Consumer<? super T> action);
```
## Можно ли итерируясь по ArrayList удалить элемент? Какое вылетит исключение?
**Можно**, но нужно использовать `iterator.remove()`.
Иначе при прохождении по `ArrayList` в цикле for сразу после удаления элемента будет `ConcurrentModificationException`.

> [!question] Как удалить элемент из ArrayList при итерации (foreach)?

```java
for (String item : arrayList) {
	if (item.length() > 2){
		arrayList.remove(item);
	}
}
```

Подвох в том, что итератор ArrayList, который используется в таком варианте цикла `for`,
является `fail-fast`, то есть не поддерживает итерацию с параллельной модификацией.
А параллельная модификация случается даже в одном потоке, что демонстрирует этот пример. Следующий шаг итератора после удаления элемента выбросит `ConcurrentModificationException`.

## Как поведёт себя коллекция, если вызвать iterator.remove()?
Если вызову `iterator.remove()` предшествовал вызов` iterator.next()`, то `iterator.remove()` удалит элемент коллекции, на который указывает итератор, в противном случае будет выброшено `IllegalStateException()`.
## Чем Set отличается от List?
`List` – **упорядоченный** список с возможностью содержания **дубликатов** и доступа по индексу (random access, произвольно получить элемент по индексу).
`Set` – не обязательно упорядоченное множество **уникальных** (с точки зрения equals) значений. Чтобы из Set получить элемент, используется `Iterator`.
## Расскажите про интерфейс Set.
Set — переводится как "множество". Интерфейс Set не добавляет новых методов к интерфейсу Collection, а лишь уточняет требования (про отсутствие дубликатов).
В основе Set лежит Map, у которого:
- ключи – это элементы множества Set;
- значения – это константа-заглушка(Object).
```java
private static final Object PRESENT = new Object();
```
- Разрешено наличие только одной ссылки типа `null`.
- Нет доступа по индексу к элементам. Это связано с тем, что порядок элементов во множестве не определён.
Множество хранит только уникальные элементы, повторяющиеся элементы в него просто не добавляются. Метод `add` у множества возвращает `true` если элемент был добавлен, и `false` если элемент уже присутствует в данном множестве.

## Расскажите про реализации интерфейса Set
Set имеет несколько связанных с собой интерфейсов.
- SortedSet
```java
public interface SortedSet<E> extends Set<E>
```
Элементы упорядочены по возрастанию. Порядок либо натуральный (элементы реализуют интерфейс `Comparable`), либо его определяет переданный в конструктор `Comparator`.
Добавляет к интерфейсу Set следующие методы: `first()` `last()` `headSet(E toElement)` `subSet(E fromElement, E toElement)` `tailSet(E fromElement)`. 

- NavigableSet
```java
public interface NavigableSet<E> extends SortedSet<E>
```
Добавляет возможность перебора сортированного множества с помощью итераторов прямого `iterator()` и обратного `descendingIterator()`
Позволяет при помощи метода `descendingSet()` получить вид на себя (View), в котором элементы идут в обратном порядке (через полученный элемент можно изменять элементы изначального Set).
Добавляет методы получения ближайшего снизу `floor()`, сверху `ceiling()`, большего `higher()` и меньшего `lower()` заданному элементу.
### Реализации
- HashSet - множество на основе хэш-кода (неупорядоченное)
- LinkedHashSet - множество на основе двусвязного списка (упорядоченное)
- TreeSet - множество на основе красно-черного дерева (отсортированное)
- EnumSet - множество для использования с перечислениями (Enum). EnumSet использует массив битов для хранения значений (bit vector), что позволяет получить высокую компактность и эффективность.

## Зачем нужны и чем отличаются интерфейсы Comparable и Comparator?
### Comparable (сравнимый)
Интерфейс `Comparable` содержит один единственный метод `int compareTo(E item)`, который сравнивает текущий объект с объектом, переданным в качестве параметра. Если этот метод возвращает отрицательное число, то текущий объект будет располагаться перед тем, который передается через параметр. Если метод вернет положительное число, то, наоборот, после второго объекта. Если метод возвратит ноль, значит, оба объекта равны.
`Comparable` реализуется ***внутри*** класса. По сути, определяет обычный/естественный порядок сравнения объектов.
### Comparator
Интерфейс `Comparator` содержит ряд методов, ключевым из которых является метод `compare()`, который возвращает числовое значение - если оно отрицательное, то объект a предшествует объекту b, иначе - наоборот. А если метод возвращает ноль, то объекты равны.
Для применения интерфейса нам сначала надо создать класс компаратора, который реализует этот интерфейс.
`Comparator` - реализуется ***вне*** класса. Можно реализовать разные варианты сортировки, основанные на сравнении различных полей (свойств объектов). Имеет ряд методов, ключевой их них – `compare()`;

## В чем отличия TreeSet и HashSet?
- Класс `HashSet` реализует интерфейс `Set`, основан на `HashMap` (оптимизирован для быстрого поиска). Не запоминает порядок добавления элементов. Может хранить `null`.
- Класс `TreeSet` реализует интерфейс `NavigableSet` реализован на основе `TreeMap` (хранит элементы в отсортированном по возрастанию порядке).

## Чем LinkedHashSet отличается от HashSet?
`LinkedHashSet` отличается от `HashSet` только тем, что в его основе лежит `LinkedHashMap` вместо `HashMap`. Благодаря этому порядок элементов при обходе коллекции является идентичным порядку добавления элементов (insertion-order, то есть хранит элементы в порядке добавления).
При добавлении элемента, который уже присутствует в LinkedHashSet (т.е. с одинаковым ключом), порядок обхода элементов не изменяется.

## Что будет, если добавлять элементы в TreeSet по возрастанию?
В основе TreeSet лежит красно-черное дерево, которое умеет само себя балансировать. В итоге, TreeSet все равно в каком порядке вы добавляете в него элементы, преимущества этой структуры данных будут сохраняться.

### Что будет в этом случае?
```java
Set<Integer> set = new TreeSet<>(new Comparator<Integer>() {  
    @Override  
    public int compare(Integer o1, Integer o2) {  
        return 0;  
    }  
});  
set.add(1);  
set.add(2);  
set.add(1);  
set.forEach(System.out::println);
```
один элемент списка, потому что переопределенный компаратор, возвращает для любой пары 0.

## Как устроен HashSet, сложность основных операций.
В основе HashSet лежит Map, у которого:
- ключи – это элементы множества Set;
- значения – это константа-заглушка(Object).
```java
private static final Object PRESENT = new Object();
```
`HashSet` хранит элементы таким образом, чтобы элемент можно было очень быстро найти. Метод `contains()` у `HashSet` ищет элемент быстро, так как под капотом `HashMap`: элементы находятся в так называемых корзинах (бакетах), которые выбираются исходя из значений самих элементов (поиск бакета по хэшкоду, см. далее HashMap).
Операции добавления, удаления и поиска будут выполняться за константное время `О(1)` (то есть быстро) при условии, что хэш-функция правильно распределяет элементы по «корзинам». Для получения элементов из `Set` используется `Iterator`, операции быстрые.
> [!info] у Set нет метода get()

Несколько важных пунктов о HashSet:
- Класс реализует интерфейс `Set`, он может хранить только уникальные значения
- Может хранить `NULL` – значения
- Порядок добавления элементов вычисляется с помощью хэш-кода
- HashSet также реализует интерфейсы `Serializable` и `Cloneable`

## Как устроен LinkedHashSet, сложность основных операций.
Класс `LinkedHashSet` расширяет класс `HashSet`, не добавляя никаких новых методов. Класс поддерживает связный список элементов множества в том порядке, в котором они вставлялись (в основе `LinkedHasMap`). Это позволяет организовать упорядоченную итерацию вставки в набор.

## Как устроен TreeSet, сложность основных операций
В основе `TreeSet` лежит `TreeMap`, у которого:
- ключи – это элементы TreeSet
- значения – это константа-заглушка
`HashSet` не может гарантировать, что данные будут отсортированы, так как работает по другому алгоритму. Если сортировка для вас важна, то используйте `TreeSet`.

![[Pasted image 20230926122432.png]]

## Расскажите про интерфейс List
List – список или упорядоченная последовательность элементов, позволяющая хранить дубликаты и null. Каждый элемент имеет индекс (от нуля и дальше), поиск по индексу.

## Как устроен ArrayList, сложность основных операций.
ArrayList реализует интерфейс `List`.

ArrayList – это динамический массив, т.е. может менять свой размер во время исполнения программы, при этом не обязательно указывать размерность при создании объекта.

Элементы ArrayList могут быть абсолютно любых типов в том числе и null.
Используем тогда, когда нам нужна структура, похожая на массив, но где нам нужно добавлять/удалять/изменять элементы. Получение и изменение элементов выполняется быстро, поскольку эти операции просто обращаются к соответствующему элементу массива».

В основе ArrayList лежит массив Object (элементами явл. Объекты типа Object).
Ёмкость capacity массива по дефолту – 10 мест (не путать размер и ёмкость).

![[Pasted image 20230926122811.png]]
- Быстрый доступ к элементам по индексу за константное время O(1)
- Доступ к элементам по значению за линейное время O(n)
- Медленный, когда вставляются и удаляются элементы из «середины» списка
- Позволяет хранить любые значения в том числе и null
- Не синхронизирован

1. Добавление элементов `list.add("0");`
	- проверяется, достаточно ли места в массиве для вставки нового элемента `ensureCapacity(size + 1);`
	- добавляется элемент в конец массива `elementData[size++] = element;`
2. Добавление в «середину» списка `list.add(5, "100");` 
	- проверяется, достаточно ли места в массиве для вставки нового элемента `ensureCapacity(size+1);`
	- подготавливается место для нового элемента `System.arraycopy(elementData, index, elementData, index + 1, size - index);`
	- перезаписывается значение у элемента с указанным индексом `elementData[index] = element; size++;`
	В случаях, когда происходит вставка элемента по индексу и при этом в вашем массиве нет свободных мест, то вызов System.arraycopy() случится дважды: первый в ensureCapacity(), второй в самом методе add(index, value), что явно скажется на скорости всей операции добавления.
	В случаях, когда в исходный список необходимо добавить другую коллекцию, да еще и в «середину», стоит использовать метод addAll(index, Collection). И хотя, данный метод скорее всего вызовет System.arraycopy() три раза, в итоге это будет гораздо быстрее поэлементного добавления.
3. Удаление элементов
	Удалять элементы можно двумя способами:
	- по индексу remove(index)
	- по значению remove(value)
	При удалении элементов текущая величина capacity не уменьшается, что может привести к своеобразным утечкам памяти. Поэтому не стоит пренебрегать методом `trimToSize()`.

## Как устроен LinkedList, сложность основных операций
LinkedList – список связанных элементов, каждый из которых хранит ссылки на следующий и предыдущий элементы в списке, цепочке. Бывает односвязный и двусвязный списки.

LinkedList — класс, реализующий два интерфейса — `List` и `Deque`. Это обеспечивает возможность создания двунаправленной очереди из любых (в том числе и `null`) элементов. Каждый объект, помещенный в связанный список, является узлом/нодом. Каждый узел содержит элемент, ссылку на предыдущий и следующий узел. Фактически связанный список состоит из последовательности узлов, каждый из которых предназначен для хранения объекта определенного при создании типа.

![[Pasted image 20230926122811.png]]

Что следует помнить о LinkedList, решая, использовать ли данную коллекцию:
- не синхронизирована
- позволяет хранить любые объекты, в том числе null и повторяющиеся
- за константное время O(1) выполняются операции вставки и удаления первого и последнего элемента и операции вставки и удаления элемента из середины списка (не учитывая время поиска позиции элемента, который осуществляется за линейное время)
- за линейное время O(n) выполняются операции поиска элемента по индексу и по значению

## Почему LinkedList реализует и List, и Deque?
За константное время O(1) выполняются операции вставки и удаления первого и последнего элемента. Это обеспечивает возможность создания двунаправленной очереди из любых (в том числе и null) элементов.

## Чем отличаются ArrayList и LinkedList?
**ArrayList** хранит данные в массиве, **LinkedList** в связанном списке. Из этого вытекает разница в эффективности разных операций:
- ArrayList лучше справляется с изменениями в середине и ростом в пределах capacity
- LinkedList – на краях. В целом обычно ArrayList лучше.
Стоит добавить, что для работы на краях лучше использовать реализации специально для этого спроектированного интерфейса **Deque**: например, реализующую кольцевой буфер **ArrayDeque**.

## Что такое Queue?
`public interface Queue<E> extends Collection<E>`
**Queue** - коллекция, предназначенная для хранения элементов в порядке, нужном для их обработки.
Очереди обычно, но не обязательно, упорядочивают элементы в FIFO (first-in-first-out) порядке. (Добавляется в конец очереди используется из начала).
`PriorityQueue`, реализация `Queue` использующая «natural ordering» или переданный `Comparator` при вставке нового элемента.

## Что такое Deque? Чем отличается от Queue?
Deque (Double Ended Queue) – это двусторонняя очередь, т.е. можно вставлять/получать элементы как из начала, так и с конца. Расширяет Queue. Согласно документации, это линейная коллекция, поддерживающая вставку/извлечение элементов с обоих концов (реализация: LIFO, либо FIFO).

## Приведите пример реализации Deque
`ArrayDeque<E>`- особый вид растущего массива, который позволяет нам добавлять или удалять элементы с обеих сторон.

Этот класс представляют обобщенную двунаправленную очередь, наследуя функционал от класса AbstractCollection и применяя интерфейс Deque.
- Не потокобезопасный;
- Нулевые элементы не принимаются;
- Работает значительно быстрее, чем синхронизированный Stack;
- Более быстрая очередь, чем LinkedList из-за лучшей локализации;
- Iterator , возвращаемый ArrayDeque , является отказоустойчивым (file-safe);
- ArrayDeque автоматически удваивает размер массива, когда head и tail указатель встречает друг друга при добавлении элемента.

## Какая коллекция реализует FIFO?
FIFO - First-In-First-Out (первый пришел, первым ушел). По этому принципу обычно построена такая структура данных, как очередь (java.util.Queue).
Можно реализовать с помощью ArrayDeque, LinkedList

## Какая коллекция реализует LIFO?
`Stack` работает по схеме LIFO (последним вошел, первым вышел, как стопка книг). Всякий раз, когда вызывается новый метод, содержащий примитивные значения или ссылки на объекты, то на вершине стека под них выделяется блок памяти.
`Stack` реализует дополнительные методы: `peek`, `pop`, `push`.

## Оцените количество памяти на хранение одного примитива типа byte в LinkedList?

структура элемента списка и расчет для 32бит (64бит):
```java
private static class Node<E> {  // заголовок 2*32 бита = 8 байт (16 байт)
	E item;                     // ссылка 32 бита = 4 байта (8 байт)
	Node<E> next;               // ссылка 32 бита = 4 байта (8 байт)
	Node<E> prev;               // ссфлка 32 бита = 4 байта (8 байт)
	...
}                               // итого 8 + 4 + 4 + 4 = 20 => 24 байт до кратности 8
                                // (итого) 16 + 8 + 8 + 8 = 40 байт

public final class Byte ... {   // заголовок 2*32 бита = 8 байт (16 байт)
...
	private final byte value;   // 1 байт => до кратности 8 = 8 байт
...
}                               // итого 24 + 16 = 40 байт
                                // (итого) 40 + 24 = 64 байта
```

## Оцените количество памяти на хранение одного примитива типа byte в ArrayList?
ArrayList основан на массиве, для примитивных типов данных осуществляется автоматическая упаковка значения, поэтому 16 байт тратится на хранение упакованного объекта и 4 байта (8 для x64) на хранение ссылки на этот объект в самой структуре данных. Таким образом, в x32 JVM 4 байта используются на хранение одного элемента и 16 байт на хранение упакованного объекта типа Byte. Для x64 - 8 байт и 24 байта соответственно.

## Какие существуют реализации Map?
![[Pasted image 20230927110751.png|600]]

## Как устроена HashMap? (Расскажите про принцип корзин)

**HashMap** - это **класс**, который реализует interface Map (пары ключей и значений):
- **ключи** элементов должны быть уникальными (и immutable), могут быть null
- **значения** элементов могут повторяться. Значение может быть null.
HashMap не запоминает порядок добавления элементов в коллекцию.
Не синхронизируемая! Нельзя использовать в условиях многопоточности, для этого есть `ConcurrentHashMap`.

В основе HashMap лежит массив **Table**, который является хранилищем для элементов корзин/бакетов (хранящих ссылки на списки/цепочки значений).
```java
transient Node<K,V>[] table;
```
**Capacity** – это ёмкость созданного массива, значение по умолчанию **16 элементов**.
**Корзины** или бакеты («buckets») – это элементы массива (ячейки), которые используются для хранения отдельно взятых узлов (или цепочек узлов).
Внутри каждой ячейки массива (корзины или бакета) лежит **односвязный** список `LinkedList`, либо лежит красное-черное дерево при перестроении (класс TreeMap). Максимальная длина связанного списка – цепочка узлов из 8 значений.

**Узел** представляет собой объект вложенного (в класс HashMap) класса Node (или TreeNode при древовидной структуре), имплементирует интерфейс `Map.Entry`, содержит поля: `hash`, `key`, `value`, `next`.
```java
static class Node<K,V> implements Map.Entry<K,V> {  
    final int hash;  
    final K key;  
    V value;  
    Node<K,V> next;
    ...
}
```

```java
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {  
    TreeNode<K,V> parent;  // red-black tree links  
    TreeNode<K,V> left;  
    TreeNode<K,V> right;  
    TreeNode<K,V> prev;    // needed to unlink next upon deletion  
    boolean red;
    ...
}
```
**LoadFactor** — коэффициент загрузки. Значение *по умолчанию 0.75* является хорошим компромиссом между временем доступа и объемом хранимых данных; Чем больше LoadFactor, тем больше экономия памяти под массив, но поиск элемента будет занимать также больше времени.
**Threshold** — предельное количество элементов, при достижении которого, размер хэштаблицы увеличивается вдвое, рассчитывается по формуле (capacity * loadFactor).
### Hash
Перед тем, как что-то сделать с объектом вычисляется его **новый** хэш-код. Для генерации используется метод hash(hashCode), в который передается key.hashCode()
```java
static final int hash(Object key) {  
    int h;  
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);  
}
```

- Это сделано из-за того, что hashCode() можно реализовать так, что только нижние биты int'a будут заполнены. Например, для Integer, Float – если мы в HashMap кладем маленькие значения, то у них и биты хеш-кодов будут заполнены только нижние. В таком случае ключи в HashMap будут иметь тенденцию скапливаться в нижних ячейках, а верхние будут оставаться пустыми, что не очень эффективно.
- На то, в какой бакет попадёт новая запись, влияют только младшие биты хеша. Поэтому и придумали различными манипуляциями подмешивать старшие биты хеша в младшие, чтобы улучшить распределение по бакетам (чтобы старшие биты родного хеша объекта начали вносить коррективы в то, в какой бакет попадёт объект) и, как следствие, производительность. Потому и придумана дополнительная функция hash внутри HashMap.

Рассчитав и зная индекс в массиве, мы получаем список (цепочку) элементов, привязанных к этой корзине (ячейке). Хэш и ключ нового элемента поочередно сравниваются с хэшами и ключами элементов из списка и, при совпадении этих параметров, значение элемента перезаписывается.
Сравниваем ключ нашего объекта с первым в цепочке объектом:
- проверка по хэш-коду
- ссылочное сравнение
- если предыдущий пункт выдал `false`, то проверка на `equals`
Если же предыдущий шаг не выявил совпадений, будет вызван метод `addEntry(hash, key, value, index)` для добавления нового элемента.

### Если при добавлении элемента возникает коллизия
Ситуация, когда разные ключи попадают в один и тот же бакет (даже с разными хешами), называется коллизией или столкновением. Даже если хеш-таблица больше, чем набор данных, и была выбрана хорошая хеш-функция, это не гарантирует того, что коллизии не возникнут. Да и значение хеша ограничено диапазоном значений типа int (порядка 4 млрд.). Полученное новое значение также нужно куда-то записать, и для этого нужно определить, куда именно оно будет записано. Это называется решением коллизии.
**Существует два подхода:**
- external chaining или метод цепочек (реализован в HashMap) — т.е. в ячейке на самом деле содержится список (chain). А уже в списке может содержаться несколько значений (не обязательно с одинаковым хеш-кодом).
- linear probing или метод открытой адресации (реализован в IdentityHashMap) – заключается в поиске первой пустой ячейки после той, на которую указала хеш-функция;

### Когда и как происходит перестроение мапы в дерево?
Первоначальный размер HashMap (capacity) = 16 бакетов. 
Когда массив заполняется на 75%, то есть заполняются 12/16 бакетов (16\*0,75 = 12, т.к. loadFactor = 0,75), размер массива увеличивается в 2 раза, т.е. становится 32 бакета. И так далее (64, 128 …).
При увеличении размера массива все объекты, уже содержащиеся в HashMap, будут перераспределены по новым бакетам, с учётом их нового количества. Каждый бакет содержит в себе ноды (пары ключ-значение), когда нодов становится 8, а бакетов 64, то структура Node перестраивается в красно-черное дерево (TreeNode).
Обратное перестроение TreeNode →Node случается, если количество нод в цепочке < 6

![[Pasted image 20230927115223.png|600]]

## Что такое LinkedHashMap? LinkedHashMap - что в нем от LinkedList, а что от HashMap?
Реализация LinkedHashMap отличается от HashMap поддержкой двухсвязного списка, определяющего порядок итерации по элементам структуры данных
Узлы реализованы так:
```java
static class Entry<K,V> extends HashMap.Node<K,V> {  
    Entry<K,V> before, after;  
    Entry(int hash, K key, V value, Node<K,V> next) {  
        super(hash, key, value, next);  
    }  
}
```

По умолчанию элементы списка упорядочены согласно их порядку добавления в LinkedHashMap (insertion-order). Однако порядок итерации можно изменить, установив параметр конструктора `accessOrder` в значение `true`. В этом случае доступ осуществляется по порядку последнего обращения к элементу (access-order). Это означает, что при вызове методов `get()` или `put()` элемент, к которому обращаемся, перемещается в конец списка. При добавлении элемента, который уже присутствует в `LinkedHashMap` (т.е. с одинаковым ключом), порядок итерации по элементам не изменяется.

## Как устроена TreeMap, сложность основных операций?
Реализация интерфейса Map — `TreeMap` позволяет хранить данные в структурированном виде с возможностью навигации.
Древовидная структура: под капотом `TreeMap` использует структуру данных, которая называется **красно-чёрное дерево**.
Имплементируя интерфейсы `NavigableMap` и `SortedMap`, `TreeMap` получает дополнительный функционал, которого нет в `HashMap`, но плата за это — производительность. 
Хоть класс TreeMap является самым многофункциональным, он не всегда может хранить null в качестве ключа. Кроме этого, время доступа к элементам TreeMap будет самым длительным. Поэтому если не нужно хранить данные в отсортированном виде, лучше использовать HashMap или LinkedHashMap.

## Что такое WeakHashMap?
В Java существует 4 типа ссылок:
- сильные (Strong reference)
- мягкие (SoftReference)
- слабые (WeakReference)
- фантомные (PhantomReference)
Особенности каждого типа ссылок связаны с работой Garbage Collector. Если объект можно достать только с помощью цепочки WeakReference (то есть на него отсутствуют сильные и мягкие ссылки), то данный объект будет помечен на удаление.
**WeakHashMap** — это структура данных, реализующая интерфейс Map и основанная на использовании `WeakReference` для хранения ключей. Таким образом, пара «ключ-значение» будет удалена из `WeakHashMap`, если на объект ключ более не имеется сильных ссылок.

> [!tip] SoftHashMap представлена в сторонних библиотеках, например, в Apache Commons.

> [!tip] PhantomReference при вызове метода get() возвращает всегда null (объект недостижим), поэтому тяжело представить назначение такой структуры данных. Фантомные ссылки — это безопасный способ узнать, что объект удален из памяти.

## Как работает HashMap при попытке сохранить в него два элемента по ключам с одинаковым hashCode(), но для которых equals() == false?
По значению `hashCode()` вычисляется индекс ячейки массива, в список которой этот элемент будет добавлен. Перед добавлением осуществляется проверка на наличие элементов в этой ячейке. Если элементы с таким `hashCode()` уже присутствует, но их `equals()` методы не равны, то элемент будет добавлен в конец списка.

## Что будет, если мы кладем в HashMap ключ, у которого equals и hashCode определены некорректно?
Объект скорее всего добавится, но обратно мы не сможем получить его.

**В каком случае может быть потерян элемент в HashMap**?
После добавления элемента в HashMap у объекта, который выступает в качестве ключа, изменяют одно поле, которое участвует в вычислении хеш-кода.
- Некорректно equals и hashcode - не найдем корзину и не найдем элемент.
- Если некорректно equals – как минимум найдем корзину хэш-таблицы, в которой объект будет лежать.
- Если некорректно hashcode - помещая некий объект в хэш-таблицу, мы рискуем не получить его обратно по ключу.

## Возможна ли ситуация, когда HashMap выродится в список даже с ключами имеющими разные hashCode()?
Это возможно в случае, если метод, определяющий номер корзины будет возвращать одинаковые значения.

## Почему нельзя использовать byte[] в качестве ключа в HashMap?
Хэш-код массива не зависит от хранимых в нем элементов, а присваивается при создании массива (метод вычисления хэш-кода массива не переопределен и вычисляется по стандартному Object.hashCode() на основании адреса массива).
Также у массивов не переопределен equals и выполняется сравнение указателей. Это приводит к тому, что обратиться к сохраненному с ключом-массивом элементу не получится при использовании другого массива такого же размера и с такими же элементами, доступ можно осуществить лишь в одном случае — при использовании той же самой ссылки на массив, что использовалась для сохранения элемента.

## Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()?
Да, будет, но в этом случае HashMap вырождается в связный список и теряет свои преимущества.

## Какое худшее время работы метода get(key) для ключа, которого НЕТ в HashMap?
O(N). Худший случай – это поиск ключа в HashMap, вырожденного в список по причине совпадения ключей по hashCode(). Для выяснения хранится ли элемент с определенным ключом может потребоваться перебор всего списка.

